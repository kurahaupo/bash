This file is shopt.def, from which is created shopt.c.
It implements the Bash `shopt' builtin.

Copyright (C) 1994-2024 Free Software Foundation, Inc.

This file is part of GNU Bash, the Bourne Again SHell.

Bash is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Bash is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Bash.  If not, see <http://www.gnu.org/licenses/>.

$PRODUCES shopt.c

$BUILTIN shopt
$FUNCTION shopt_builtin
$SHORT_DOC shopt [-oOpP] [-q] [-su] [OPTNAME ...]
shopt [-oOpP] [-q] [-su] [OPTNAME ...]
shopt [--list-options | --option-help | --option-usage | -[fhH] ] [OPTNAME ...]
Display or change shell options.

If one or more OPTNAMEs is given, and one of "-s" or "-u" is given, and neither
"-p" nor "-P" is given, then the named options will be set (if "-s" is given)
or unset (if "-u" is given).

Otherwise "shopt" will display options. Initially all options are candidates
for display, but:
 - if "-o" is given, limit the display to only those candidates defined for use
   with "set -o"; if "-O" is given make the inverse limitation.
 - if "-s" is given, limit the display to only "set"/"on" candidates
 - if "-u" is given, limit the display to only "unset"/"off" candidates
 - if OPTNAMEs are given, limit the display to those candidates that are among
   the OPTNAMEs.

Options:
  -o	restrict OPTNAMEs to those defined for use with "set -o"
  -O	restrict OPTNAMEs to those not defined for use with "set -o"
  -p, -P
	Display each shell option in a form that can be re-used as shell input
	-P	output as "shopt" commands
	-Pp	output as "set -o" commands
	-p	output as "set -o" commands if "-o" is also given;
		output as "shopt" commands if "-o" is not given.
	Otherwise show each option name with 'on' or 'off'.
  -q	Suppress output (only return exit status)
  -s	Enable (set) each OPTNAME (or limit output with -p or -P)
  -u	Disable (unset) each OPTNAME (or limit output with -p or -P)

Exit Status:
Returns success if all OPTNAMEs are enabled; fails if an invalid option is
given or if any OPTNAME is disabled.

Type "shopt --list-options" to see a brief list of options.
Type "shopt --option-help [OPTNAME ...]" to see short help for each option.
Type "shopt --option-usage [OPTNAME ...]" to see detailed help for each option.
$END

#include <config.h>

#if defined (HAVE_UNISTD_H)
#  ifdef _MINIX
#    include <sys/types.h>
#  endif
#  include <unistd.h>
#endif

#include <stdio.h>

#include "version.h"

#include "../bashintl.h"

#include "../shell.h"
#include "../flags.h"
#include "../options.h"
#include "common.h"
#include "bashgetopt.h"

#if defined (READLINE)
#  include "../bashline.h"
#endif

#if defined (HISTORY)
#  include "../bashhist.h"
#endif

extern int allow_null_glob_expansion;
extern int autocd;
extern int bash_source_fullpath;
extern int cdable_vars;
extern int cdspelling;
extern int check_hashed_filenames;
extern int check_jobs_at_exit;
extern int check_window_size;
extern int expand_aliases;
extern int extended_quote;
extern int fail_glob_expansion;
extern int glob_always_skip_dot_and_dotdot;
extern int glob_asciirange;
extern int glob_dot_filenames;
extern int glob_ignore_case;
extern int glob_star;
extern int gnu_error_format;
extern int hup_on_exit;
extern int inherit_errexit;
extern int lastpipe_opt;
extern int localvar_inherit;
extern int localvar_unset;
extern int mail_warning;
extern int match_ignore_case;
extern int no_exit_on_failed_exec;
extern int patsub_replacement;
extern int print_shift_error;
extern int promptvars;
extern int singlequote_translations;
extern int source_uses_path;
extern int varassign_redir_autoclose;
extern int xpg_echo;

#if defined (EXTENDED_GLOB)
extern int extended_glob;
#endif

#if defined (READLINE)
extern int complete_fullquote;
extern int dircomplete_expand;
extern int dircomplete_spelling;
extern int force_fignore;
extern int hist_verify;
extern int history_reediting;
extern int no_empty_command_completion;
extern int perform_hostname_completion;

extern int enable_hostname_completion (int);
#endif

#if defined (PROGRAMMABLE_COMPLETION)
extern int prog_completion_enabled;
extern int progcomp_alias;
#endif

#if defined (DEBUGGER)
extern int debugging_mode;
#endif

#if defined (ARRAY_VARS)
extern int array_expand_once;
#endif

#if defined (SYSLOG_HISTORY)
extern int syslog_history;
#endif

static void shopt_error (char const*);

#if 0
static opt_set_func_t set_shellopts_after_change;
#endif
static opt_get_func_t get_compatibility_level;
static opt_set_func_t set_compatibility_level;

#if defined (RESTRICTED_SHELL)
static opt_set_func_t set_restricted_shell;
#endif

#if defined (READLINE)
static opt_set_func_t shopt_enable_hostname_completion;
static opt_set_func_t shopt_set_complete_direxpand;
#endif

#if defined (EXTENDED_GLOB)
int extglob_flag = EXTGLOB_DEFAULT;
static opt_set_func_t shopt_set_extglob;
#endif

int expaliases_flag = 0;
static opt_set_func_t shopt_set_expaliases;

static opt_set_func_t shopt_set_debug_mode;

static int shopt_login_shell;

typedef int shopt_set_func_t (char *, int);

/* If you add a new variable name here, make sure to set the default value
   appropriately in reset_shopt_options. */

/*
 * Keep aach option's terms in this order:
 *  Name, Letter
 *  Store (pointer)
 *  Init (pointer), Skip-reset
 *  Getter & Setter functions, Reference value
 *  Read-only, Forbid-change, Ignore-change
 *  (everything else in alphabetical order)
 *  Help
 */

static opt_def_t const xo_options[] = {
#if defined (ARRAY_VARS)
  { "array_expand_once",
    .store = &array_expand_once,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "assoc_expand_once",
    .store = &array_expand_once,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .hide_shopt = true,
  },
#endif
  { "autocd",
    .store = &autocd,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
#if defined (ARRAY_VARS)
  { "bash_source_fullpath",
    .store = &bash_source_fullpath,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
#endif
  { "cdable_vars",
    .store = &cdable_vars,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "cdspell",
    .store = &cdspelling,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "checkhash",
    .store = &check_hashed_filenames,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
#if defined (JOB_CONTROL)
  { "checkjobs",
    .store = &check_jobs_at_exit,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
#endif
  { "checkwinsize",
    .store = &check_window_size,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
#if defined (HISTORY)
  { "cmdhist",
    .store = &command_oriented_history,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
#endif
  { "compat31",
    .set_func = set_compatibility_level,
    .get_func = get_compatibility_level,
    .reference_value = 31,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "compat32",
    .set_func = set_compatibility_level,
    .get_func = get_compatibility_level,
    .reference_value = 32,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "compat40",
    .set_func = set_compatibility_level,
    .get_func = get_compatibility_level,
    .reference_value = 40,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "compat41",
    .set_func = set_compatibility_level,
    .get_func = get_compatibility_level,
    .reference_value = 41,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "compat42",
    .set_func = set_compatibility_level,
    .get_func = get_compatibility_level,
    .reference_value = 42,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "compat43",
    .set_func = set_compatibility_level,
    .get_func = get_compatibility_level,
    .reference_value = 43,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "compat44",
    .set_func = set_compatibility_level,
    .get_func = get_compatibility_level,
    .reference_value = 44,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "compat50",
    .set_func = set_compatibility_level,
    .get_func = get_compatibility_level,
    .reference_value = 50,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .hide_shopt = true,
  },
  { "compat51",
    .set_func = set_compatibility_level,
    .get_func = get_compatibility_level,
    .reference_value = 51,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .hide_shopt = true,
  },
  { "compat52",
    .set_func = set_compatibility_level,
    .get_func = get_compatibility_level,
    .reference_value = 52,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .hide_shopt = true,
  },
  { "compat53",
    .set_func = set_compatibility_level,
    .get_func = get_compatibility_level,
    .reference_value = 53,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .hide_shopt = true,
  },
  { "compat54",
    .set_func = set_compatibility_level,
    .get_func = get_compatibility_level,
    .reference_value = 54,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .hide_shopt = true,
  },
#if defined (READLINE)
  { "complete_fullquote",
    .store = &complete_fullquote,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "direxpand",
    .store = &dircomplete_expand,
    .set_func = shopt_set_complete_direxpand,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "dirspell",
    .store = &dircomplete_spelling,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
#endif
  { "dotglob",
    .store = &glob_dot_filenames,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "execfail",
    .store = &no_exit_on_failed_exec,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "expand_aliases",
    .store = &expaliases_flag,
    .set_func = shopt_set_expaliases,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
#if defined (DEBUGGER)
  { "extdebug",
    .store = &debugging_mode,
    .set_func = shopt_set_debug_mode,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
#endif
#if defined (EXTENDED_GLOB)
  { "extglob",
    .store = &extglob_flag,
    .set_func = shopt_set_extglob,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
#endif
  { "extquote",
    .store = &extended_quote,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "failglob",
    .store = &fail_glob_expansion,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
#if defined (READLINE)
  { "force_fignore",
    .store = &force_fignore,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
#endif
  { "globasciiranges",
    .store = &glob_asciirange,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "globskipdots",
    .store = &glob_always_skip_dot_and_dotdot,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "globstar",
    .store = &glob_star,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "gnu_errfmt",
    .store = &gnu_error_format,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
#if defined (HISTORY)
  { "histappend",
    .store = &force_append_history,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
#endif
#if defined (READLINE)
  { "histreedit",
    .store = &history_reediting,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "histverify",
    .store = &hist_verify,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "hostcomplete",
    .store = &perform_hostname_completion,
    .set_func = shopt_enable_hostname_completion,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
#endif
  { "huponexit",
    .store = &hup_on_exit,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "inherit_errexit",
    .store = &inherit_errexit,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "interactive_comments",
    .store = &interactive_comments,
    #if 0
    .set_func = set_shellopts_after_change,
    #endif
    .adjust_bashopts = true,
    .adjust_shellopts = true,
    .hide_set_o = true,
  },
  { "lastpipe",
    .store = &lastpipe_opt,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
#if defined (HISTORY)
  { "lithist",
    .store = &literal_history,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
#endif
  { "localvar_inherit",
    .store = &localvar_inherit,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "localvar_unset",
    .store = &localvar_unset,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "login_shell",
    .store = &login_shell,
    .ignore_change = true,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "mailwarn",
    .store = &mail_warning,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
#if defined (READLINE)
  { "no_empty_cmd_completion",
    .store = &no_empty_command_completion,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
#endif
  { "nocaseglob",
    .store = &glob_ignore_case,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "nocasematch",
    .store = &match_ignore_case,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "noexpand_translation",
    .store = &singlequote_translations,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "nullglob",
    .store = &allow_null_glob_expansion,
    .OPTRESET_false,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "patsub_replacement",
    .store = &patsub_replacement,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
#if defined (PROGRAMMABLE_COMPLETION)
  { "progcomp",
    .store = &prog_completion_enabled,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
#  if defined (ALIAS)
  { "progcomp_alias",
    .store = &progcomp_alias,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
#  endif
#endif
  { "promptvars",
    .store = &promptvars,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
#if defined (RESTRICTED_SHELL)
  { "restricted_shell",
    .store = &restricted_shell,
    .set_func = set_restricted_shell,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
#endif
  { "shift_verbose",
    .store = &print_shift_error,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "sourcepath",
    .store = &source_uses_path,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
#if defined (SYSLOG_HISTORY) && defined (SYSLOG_SHOPT)
  { "syslog_history",
    .store = &syslog_history,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
#endif
  { "varredir_close",
    .store = &varassign_redir_autoclose,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
  { "xpg_echo",
    .store = &xpg_echo,
    .adjust_bashopts = true,
    .hide_set_o = true,
  },
};

/*
 * By default, show *all* options (both shopt and set -o), using the 'standard' format.
 * Otherwise:
 *  Selection:
 *  ‧ `-o` only show classic `set -o` options
 *  ‧ `-O` don't show classic `set -o` options
 *  ‧ (otherwise show all)
 *  Format:
 *  ‧ `-po` or `-Pp` use `set -o` reusable format
 *  ‧ `-p`  or `-P`  use `shopt` reusable format
 *  ‧ (otherwise use 'standard' format)
 *  (The intention is that `-P` is like `-p` but insensitive to whether `-o`
 *   has been used to select the classic `set -o` subset; for completeness,
 *   using both `-Pp` uses the `set -o` format without limiting the selection.)
 * Note that --short-help and --long-help are simply treated as
 * "display" with a funny display style.
 */

static inline _Bool
match (char const *arg, char const *pattern, size_t min)
{
  size_t plen = strlen (pattern);
  if (min == 0 || min > plen)
    min = plen;
  size_t alen = strlen (arg);
  return min <= alen && alen <= plen
      && 0 == memcmp (arg, pattern, alen);
}

int
shopt_builtin (WORD_LIST *list)
{
  int help_level = 0;
  _Bool mode_O = false;
  _Bool mode_P = false;
  _Bool mode_o = false;
  _Bool mode_p = false;
  _Bool quiet = false;
  _Bool universal = false;
  _Bool value_s = false;
  _Bool value_u = false;

  /* Long options must come before short options ... */
  for (char const *arg; list && list->word && (arg = list->word->word) != NULL && arg[0] == '-' && arg[1] == '-' && arg[2] != 0 ;list = list->next)
    {
      if (match (arg, "--list-options", 3)) { help_level = 1; continue; }
      if (match (arg, "--options", 3) || match (arg, "--option-help", 10) || match (arg, "--help-options", 8)) { help_level = 2; continue; }
      if (match (arg, "--usage",   3) || match (arg, "--option-usage", 10)) { help_level = 3; continue; }
      builtin_usage ();
      return (EX_USAGE);
    }

  /* ... and short options must come before OPTNAMEs */
  reset_internal_getopt ();
  int opt;
  while ((opt = internal_getopt (list, "fHhoOpPqsSu")) != -1)
    {
      switch (opt)
	{
	case 'f': help_level = 3; break;
	case 'H': help_level = 2; break;
	case 'h': help_level = 1; break;
	case 'o': mode_o = true; break;	/* emulate set -o (both choice and format) */
	case 'O': mode_O = true; break;	/* inverse of -o choice */
	case 'p': mode_p = true; break;
	case 'P': mode_P = true; break;
	case 'q': quiet = true; break;
	case 's': value_s = true; break;
	case 'u': value_u = true; break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  accessor_t oc = mode_o ? Accessor (set_o) :
		  mode_O ? Accessor (shopt) :
			   Accessor (any);

  display_style_t ds = help_level > 0 ? DisplayStyle (help1-1+help_level) :
		 ! mode_p && ! mode_P ? DisplayStyle (on_off) :
		    (mode_P ? mode_p
			    : mode_o) ? DisplayStyle (set_o)
				      : DisplayStyle (shopt);

  unsigned int value_comb = value_s == value_u ? 0 : 1 << !value_s;

  int rval = EXECUTION_SUCCESS;
  if (list == NULL)
    {
      if (quiet == 0)
	list_all_options (oc, value_comb, ds);
    }
  else if (!(value_s || value_u) || mode_p || mode_P || help_level > 0)
    {
      for (WORD_LIST *l = list; l; l = l->next)
	{
	  char const*name = l->word->word;
	  opt_def_t const *d = find_option (name);
	  if (! d)
	    {
	      shopt_error (name);
	      rval = EXECUTION_FAILURE;
	      continue;
	    }
	  int val = get_opt_value (d, oc);
	  if (value_comb &&
	      value_comb & 1U << val)
	    continue;
	  if (val == 0)
	    rval = EXECUTION_FAILURE;
	  if (! quiet)
	    show_one_option (d, oc, ds);
	}
    }
  else
    {
      if (value_s && value_u)
	{
	  builtin_error (_("cannot set and unset shell options simultaneously"));
	  return (EXECUTION_FAILURE);
	}
      for (WORD_LIST *l = list; l; l = l->next)
	{
	  char const*name = l->word->word;
	  opt_def_t const *d = find_option (name);
	  if (! d)
	    {
	      shopt_error (name);
	      rval = EXECUTION_FAILURE; /* TODO: maybe EX_BADUSAGE ? */
	      continue;
	    }
	  op_result_t r = set_opt_value (d, oc, value_s);
	  if (! GoodResult (r))
	    rval = EXECUTION_FAILURE;
	}

      #if 0 /* not needed - this is handled by set_opt_value */
      /* Don't set $BASHOPTS here if it hasn't already been initialized */
      if (find_variable ("BASHOPTS"))
	set_bashopts ();
      #endif
    }
  return sh_chkwrite (rval);
}

/* Reset the options managed by `shopt' to the values they would have at
   shell startup.  Variables from xo_options. */
void
reset_shopt_options (void)
{
  autocd = 0;
  bash_source_fullpath = 0;
  cdable_vars = 0;
  cdspelling = 0;
  expaliases_flag = 0;
  expand_aliases = 0;
  fail_glob_expansion = 0;
  glob_dot_filenames = 0;
  glob_ignore_case = 0;
  glob_star = 0;
  gnu_error_format = 0;
  hup_on_exit = 0;
  inherit_errexit = 0;
  lastpipe_opt = 0;
  localvar_inherit = 0;
  localvar_unset = 0;
  mail_warning = 0;
  match_ignore_case = 0;
  no_exit_on_failed_exec = 0;
  print_shift_error = 0;
  singlequote_translations = 0;
  varassign_redir_autoclose = 0;

  extended_quote = 1;
  interactive_comments = 1;
  promptvars = 1;
  source_uses_path = 1;

  check_hashed_filenames = CHECKHASH_DEFAULT;
  check_window_size = CHECKWINSIZE_DEFAULT;
  glob_asciirange = GLOBASCII_DEFAULT;
  patsub_replacement = PATSUB_REPLACE_DEFAULT;

#if defined (JOB_CONTROL)
  check_jobs_at_exit = 0;
#endif

#if defined (EXTENDED_GLOB)
  extended_glob = EXTGLOB_DEFAULT;
  extglob_flag = EXTGLOB_DEFAULT;
#endif
  glob_always_skip_dot_and_dotdot = 1;		/* new default as of bash-5.2 */

#if defined (ARRAY_VARS)
  array_expand_once = 0;
#endif

#if defined (HISTORY)
  command_oriented_history = 1;
  force_append_history = 0;
  literal_history = 0;
#endif

#if defined (SYSLOG_HISTORY)
#  if defined (SYSLOG_SHOPT)
  syslog_history = SYSLOG_SHOPT;
#  else
  syslog_history = 1;
#  endif /* SYSLOG_SHOPT */
#endif

#if defined (READLINE)
  complete_fullquote = 1;
  force_fignore = 1;
  hist_verify = history_reediting = 0;
  perform_hostname_completion = 1;
#  if DIRCOMPLETE_EXPAND_DEFAULT
  dircomplete_expand = 1;
#  else
  dircomplete_expand = 0;
#endif
  dircomplete_spelling = 0;
  no_empty_command_completion = 0;
#endif

#if defined (PROGRAMMABLE_COMPLETION)
  prog_completion_enabled = 1;
#  if defined (ALIAS)
  progcomp_alias = 0;
#  endif
#endif

#if defined (DEFAULT_ECHO_TO_XPG) || defined (STRICT_POSIX)
  xpg_echo = 1;
#else
  xpg_echo = 0;
#endif /* DEFAULT_ECHO_TO_XPG */

#if defined (DEBUGGER)
  debugging_mode = 0;
#endif
}

static void
shopt_error (char const*s)
{
  builtin_error (_("%s: invalid shell option name"), s);
}

#if 0 /* already covered by set_opt_value when .adjust_shellopts is true */
/* If we set or unset interactive_comments with shopt, make sure the
   change is reflected in $SHELLOPTS. */
/* Note that this is in addition to adjusting $BASHOPTS, which is triggered
   by .adjust_bashopts. */
static op_result_t
set_shellopts_after_change (opt_def_t const *d, accessor_t why, int mode)
{
  d->store[0] = mode;
  set_shellopts ();
  return Result (OK);
}
#endif

static op_result_t
shopt_set_debug_mode (opt_def_t const *d, accessor_t why, int mode)
{
  d->store[0] = mode;
#if defined (DEBUGGER)
  error_trace_mode = function_trace_mode = debugging_mode;
  set_shellopts ();
  if (debugging_mode)
    init_bash_argv ();
#endif
  return Result (OK);
}

static op_result_t
shopt_set_expaliases (opt_def_t const *d, accessor_t why, int mode)
{
  d->store[0] = mode;
  expand_aliases = expaliases_flag;
  return Result (OK);
}

#if defined (EXTENDED_GLOB)
static op_result_t
shopt_set_extglob (opt_def_t const *d, accessor_t why, int mode)
{
  d->store[0] = mode;
  extended_glob = extglob_flag;
  return Result (OK);
}
#endif

#if defined (READLINE)
static op_result_t
shopt_enable_hostname_completion (opt_def_t const *d, accessor_t why, int mode)
{
  d->store[0] = mode;
  enable_hostname_completion (mode);
  return Result (OK);
}
#endif

static op_result_t
set_compatibility_level (opt_def_t const *d, accessor_t why, int mode)
{
  if (mode)
    shell_compatibility_level = d->reference_value;
  else if (shell_compatibility_level == d->reference_value)
    shell_compatibility_level = DEFAULT_COMPAT_LEVEL;
  else
    return Result (Ignored);

  /* Make sure the current compatibility level is reflected in BASH_COMPAT */
  char *rhs = itos (shell_compatibility_level);
  bind_variable ("BASH_COMPAT", rhs, 0);
  free (rhs);

  return Result (OK);
}

static option_value_t
get_compatibility_level (opt_def_t const *d, accessor_t why)
{
  return shell_compatibility_level == d->reference_value;
}

/* Set and unset the various compatibility options from the value of
   shell_compatibility_level; used by sv_shcompat
   TODO - no longer required */
void
set_compatibility_opts (void)
{
}

#if defined (READLINE)
static op_result_t
shopt_set_complete_direxpand (opt_def_t const *d, accessor_t why, int mode)
{
  d->store[0] = mode;
  set_directory_hook ();
  return Result (OK);
}
#endif

#if defined (RESTRICTED_SHELL)
/* Don't allow the value of restricted_shell to be modified. */

static op_result_t
set_restricted_shell (opt_def_t const *d, accessor_t why, int mode)
{
  d->store[0] = mode;

  static int save_restricted = -1;

  if (save_restricted == -1)
    save_restricted = shell_is_restricted (shell_name);

  restricted_shell = save_restricted;
  return Result (OK);
}
#endif /* RESTRICTED_SHELL */

/* Not static so shell.c can call it to initialize shopt_login_shell */
int
set_login_shell (char *option_name, int mode)
{
  return (0);
}

char **
get_shopt_options (void)
{
  size_t n = count_options_class (Accessor (shopt));
  char **ret = strvec_create (n + 1);
  opt_def_t const *d;
  size_t i = 0;
  for_each_option_class (d, Accessor (shopt))
    ret[i++] = savestring (d->name);
  ret[i] = NULL;
  return ret;
}

/*
 * External interface for other parts of the shell.  NAME is a string option;
 * MODE is 0 if we want to unset an option; 1 if we want to set an option.
 */
int
shopt_setopt (char const *name, int mode)
{
  opt_def_t const *d = find_option (name);
  if (! d)
    {
      shopt_error (name);
      return EXECUTION_FAILURE; /* TODO: maybe EX_BADUSAGE ? */
    }

  int rval = EXECUTION_SUCCESS;

  op_result_t r = set_opt_value (d, Accessor (shopt), mode);
  if (! GoodResult (r))
    rval = EXECUTION_FAILURE;

  /* Don't set $BASHOPTS here if it hasn't already been initialized */
  if (find_variable ("BASHOPTS"))
    set_bashopts ();
  return rval;
}

void
set_bashopts (void)
{
  size_t count = count_options ();
  char *tflag = xmalloc (count + 1);

  size_t vsize = 0;
  {
    size_t i = 0;
    opt_def_t const *d;
    for_each_option_class (d, Accessor (shopt))
      {
	int val = get_opt_value (d, Accessor (env_bashopts));
	tflag[i++] = val;
	if (val)
	  vsize += strlen (d->name) + 1;
      }
  }

  char const *value;

  {
    char *vend = xmalloc (vsize + 1);
    value = vend;
    size_t i = 0;
    opt_def_t const *d;
    for_each_option_class (d, Accessor (shopt))
      if (tflag[i++])
	{
	  vend = stpcpy (vend, d->name);
	  *vend++ = ':';
	}
    if (vend > value)
      vend--;			/* cut off trailing colon */
    *vend = '\0';
  }

  xfree (tflag);

  /* ASS_FORCE so we don't have to temporarily turn off readonly;
   * ASS_NOMARK so we don't tickle `set -a`. */
  SHELL_VAR *var = bind_variable ("BASHOPTS", value, ASS_FORCE | ASS_NOMARK);
  free (value);

  /* Turn the read-only attribute back on. */
  VSETATTR (var, att_readonly);
}

static void
parse_bashopts (char const*value)
{
  char const*vname;
  int vptr;

  vptr = 0;
  while (vname = extract_colon_unit (value, &vptr))
    {
      opt_def_t const *d = find_option (vname);
      if (d)
	set_opt_value(d, Accessor (env_bashopts), true);
      free (vname);
    }
}

void
initialize_bashopts (_Bool no_bashopts)
{
  if (!no_bashopts)
    {
      SHELL_VAR *var = find_variable ("BASHOPTS");
      /* set up any shell options we may have inherited. */
      if (var && imported_p (var) && !(array_p (var) || assoc_p (var)))
	{
	  char *temp = savestring (value_cell (var));
	  if (temp)
	    {
	      parse_bashopts (temp);
	      free (temp);
	    }
	}
    }

  /* Set up the $BASHOPTS variable. */
  set_bashopts ();
}

void
list_shopts (int reusable)
{
  display_style_t ds = reusable ? DisplayStyle (shopt) : DisplayStyle (on_off);
  opt_def_t const *d;
  for_each_option_class (d, Accessor (shopt))
    show_one_option (d, Accessor (shopt), ds);
}

void
register_shopt_opts (void)
{
  for (size_t i = 0 ; i < (sizeof (xo_options) / sizeof (xo_options[0])) ; ++i)
    register_option (&xo_options[i]);
}
