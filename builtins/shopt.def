This file is shopt.def, from which is created shopt.c.
It implements the Bash `shopt' builtin.

Copyright (C) 1994-2024 Free Software Foundation, Inc.

This file is part of GNU Bash, the Bourne Again SHell.

Bash is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Bash is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Bash.  If not, see <http://www.gnu.org/licenses/>.

$PRODUCES shopt.c

$BUILTIN shopt
$FUNCTION shopt_builtin
$SHORT_DOC shopt [-pqsu] [-o] [optname ...]
Set and unset shell options.

Change the setting of each shell option OPTNAME.  Without any option
arguments, list each supplied OPTNAME, or all shell options if no
OPTNAMEs are given, with an indication of whether or not each is set.

Options:
  -o	restrict OPTNAMEs to those defined for use with `set -o'
  -p	print each shell option with an indication of its status
  -q	suppress output
  -s	enable (set) each OPTNAME
  -u	disable (unset) each OPTNAME

Exit Status:
Returns success if OPTNAME is enabled; fails if an invalid option is
given or OPTNAME is disabled.
$END

#include <config.h>

#if defined (HAVE_UNISTD_H)
#  ifdef _MINIX
#    include <sys/types.h>
#  endif
#  include <unistd.h>
#endif

#include <stdio.h>

#include "version.h"

#include "../bashintl.h"

#include "../shell.h"
#include "../flags.h"
#include "../options.h"
#include "common.h"
#include "bashgetopt.h"

#if defined (READLINE)
#  include "../bashline.h"
#endif

#if defined (HISTORY)
#  include "../bashhist.h"
#endif

#define UNSETOPT	0
#define SETOPT		1

#define OPTFMT		"%-15s\t%s\n"

extern int allow_null_glob_expansion, fail_glob_expansion, glob_dot_filenames;
extern int cdable_vars, mail_warning, source_uses_path;
extern int no_exit_on_failed_exec, print_shift_error;
extern int check_hashed_filenames, promptvars;
extern int cdspelling, expand_aliases;
extern int extended_quote;
extern int check_window_size;
extern int glob_ignore_case, match_ignore_case;
extern int hup_on_exit;
extern int xpg_echo;
extern int gnu_error_format;
extern int check_jobs_at_exit;
extern int autocd;
extern int glob_star;
extern int glob_asciirange;
extern int glob_always_skip_dot_and_dotdot;
extern int lastpipe_opt;
extern int inherit_errexit;
extern int localvar_inherit;
extern int localvar_unset;
extern int varassign_redir_autoclose;
extern int singlequote_translations;
extern int patsub_replacement;
extern int bash_source_fullpath;

#if defined (EXTENDED_GLOB)
extern int extended_glob;
#endif

#if defined (READLINE)
extern int hist_verify, history_reediting, perform_hostname_completion;
extern int no_empty_command_completion;
extern int force_fignore;
extern int dircomplete_spelling, dircomplete_expand;
extern int complete_fullquote;

extern int enable_hostname_completion (int);
#endif

#if defined (PROGRAMMABLE_COMPLETION)
extern int prog_completion_enabled;
extern int progcomp_alias;
#endif

#if defined (DEBUGGER)
extern int debugging_mode;
#endif

#if defined (ARRAY_VARS)
extern int array_expand_once;
int expand_once_flag;
#endif

#if defined (SYSLOG_HISTORY)
extern int syslog_history;
#endif

static void shopt_error (char const*);

static opt_set_func_t set_shellopts_after_change;
static opt_get_func_t get_compatibility_level;
static opt_set_func_t set_compatibility_level;

#if defined (RESTRICTED_SHELL)
static opt_set_func_t set_restricted_shell;
#endif

#if defined (READLINE)
static opt_set_func_t shopt_enable_hostname_completion;
static opt_set_func_t shopt_set_complete_direxpand;
#endif

#if defined (ARRAY_VARS)
static opt_set_func_t set_array_expand;
#endif

#if defined (EXTENDED_GLOB)
int extglob_flag = EXTGLOB_DEFAULT;
static opt_set_func_t shopt_set_extglob;
#endif

int expaliases_flag = 0;
static opt_set_func_t shopt_set_expaliases;

static opt_set_func_t shopt_set_debug_mode;

static int shopt_login_shell;

typedef int shopt_set_func_t (char *, int);

/* If you add a new variable name here, make sure to set the default value
   appropriately in reset_shopt_options. */

static opt_def_t const xo_options[] = {
#if defined (ARRAY_VARS)
  { "array_expand_once",	.hide_set_o = true,	.adjust_bashopts = true,	.store = &expand_once_flag,		.set_func = set_array_expand },
  { "assoc_expand_once",	.hide_set_o = true,	.adjust_bashopts = true,	.store = &expand_once_flag,		.set_func = set_array_expand },
#endif
  { "autocd",			.hide_set_o = true,	.adjust_bashopts = true,	.store = &autocd },
#if defined (ARRAY_VARS)
  { "bash_source_fullpath",	.hide_set_o = true,	.adjust_bashopts = true,	.store = &bash_source_fullpath },
#endif
  { "cdable_vars",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &cdable_vars },
  { "cdspell",			.hide_set_o = true,	.adjust_bashopts = true,	.store = &cdspelling },
  { "checkhash",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &check_hashed_filenames },
#if defined (JOB_CONTROL)
  { "checkjobs",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &check_jobs_at_exit },
#endif
  { "checkwinsize",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &check_window_size },
#if defined (HISTORY)
  { "cmdhist",			.hide_set_o = true,	.adjust_bashopts = true,	.store = &command_oriented_history },
#endif
  { "compat31",			.hide_set_o = true,	.adjust_bashopts = true,						.set_func = set_compatibility_level,	.get_func = get_compatibility_level,	.reference_value = 31 },
  { "compat32",			.hide_set_o = true,	.adjust_bashopts = true,						.set_func = set_compatibility_level,	.get_func = get_compatibility_level,	.reference_value = 32 },
  { "compat40",			.hide_set_o = true,	.adjust_bashopts = true,						.set_func = set_compatibility_level,	.get_func = get_compatibility_level,	.reference_value = 40 },
  { "compat41",			.hide_set_o = true,	.adjust_bashopts = true,						.set_func = set_compatibility_level,	.get_func = get_compatibility_level,	.reference_value = 41 },
  { "compat42",			.hide_set_o = true,	.adjust_bashopts = true,						.set_func = set_compatibility_level,	.get_func = get_compatibility_level,	.reference_value = 42 },
  { "compat43",			.hide_set_o = true,	.adjust_bashopts = true,						.set_func = set_compatibility_level,	.get_func = get_compatibility_level,	.reference_value = 43 },
  { "compat44",			.hide_set_o = true,	.adjust_bashopts = true,						.set_func = set_compatibility_level,	.get_func = get_compatibility_level,	.reference_value = 44 },
#if defined (READLINE)
  { "complete_fullquote",	.hide_set_o = true,	.adjust_bashopts = true,	.store = &complete_fullquote },
  { "direxpand",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &dircomplete_expand,		.set_func = shopt_set_complete_direxpand },
  { "dirspell",			.hide_set_o = true,	.adjust_bashopts = true,	.store = &dircomplete_spelling },
#endif
  { "dotglob",			.hide_set_o = true,	.adjust_bashopts = true,	.store = &glob_dot_filenames },
  { "execfail",			.hide_set_o = true,	.adjust_bashopts = true,	.store = &no_exit_on_failed_exec },
  { "expand_aliases",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &expaliases_flag,		.set_func = shopt_set_expaliases },
#if defined (DEBUGGER)
  { "extdebug",			.hide_set_o = true,	.adjust_bashopts = true,	.store = &debugging_mode,		.set_func = shopt_set_debug_mode },
#endif
#if defined (EXTENDED_GLOB)
  { "extglob",			.hide_set_o = true,	.adjust_bashopts = true,	.store = &extglob_flag,			.set_func = shopt_set_extglob },
#endif
  { "extquote",			.hide_set_o = true,	.adjust_bashopts = true,	.store = &extended_quote },
  { "failglob",			.hide_set_o = true,	.adjust_bashopts = true,	.store = &fail_glob_expansion },
#if defined (READLINE)
  { "force_fignore",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &force_fignore },
#endif
  { "globasciiranges",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &glob_asciirange },
  { "globskipdots",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &glob_always_skip_dot_and_dotdot },
  { "globstar",			.hide_set_o = true,	.adjust_bashopts = true,	.store = &glob_star },
  { "gnu_errfmt",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &gnu_error_format },
#if defined (HISTORY)
  { "histappend",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &force_append_history },
#endif
#if defined (READLINE)
  { "histreedit",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &history_reediting },
  { "histverify",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &hist_verify },
  { "hostcomplete",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &perform_hostname_completion,	.set_func = shopt_enable_hostname_completion },
#endif
  { "huponexit",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &hup_on_exit },
  { "inherit_errexit",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &inherit_errexit },
  { "interactive_comments",	.hide_set_o = true,	.adjust_bashopts = true,	.store = &interactive_comments,		.set_func = set_shellopts_after_change },
  { "lastpipe",			.hide_set_o = true,	.adjust_bashopts = true,	.store = &lastpipe_opt },
#if defined (HISTORY)
  { "lithist",			.hide_set_o = true,	.adjust_bashopts = true,	.store = &literal_history },
#endif
  { "localvar_inherit",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &localvar_inherit },
  { "localvar_unset",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &localvar_unset },
  { "login_shell",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &login_shell,			.ignore_change = true },	/* attempts to change this are ignored */
  { "mailwarn",			.hide_set_o = true,	.adjust_bashopts = true,	.store = &mail_warning },
#if defined (READLINE)
  { "no_empty_cmd_completion",	.hide_set_o = true,	.adjust_bashopts = true,	.store = &no_empty_command_completion },
#endif
  { "nocaseglob",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &glob_ignore_case },
  { "nocasematch",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &match_ignore_case },
  { "noexpand_translation",	.hide_set_o = true,	.adjust_bashopts = true,	.store = &singlequote_translations },
  { "nullglob",			.hide_set_o = true,	.adjust_bashopts = true,	.store = &allow_null_glob_expansion },
  { "patsub_replacement",	.hide_set_o = true,	.adjust_bashopts = true,	.store = &patsub_replacement },
#if defined (PROGRAMMABLE_COMPLETION)
  { "progcomp",			.hide_set_o = true,	.adjust_bashopts = true,	.store = &prog_completion_enabled },
#  if defined (ALIAS)
  { "progcomp_alias",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &progcomp_alias },
#  endif
#endif
  { "promptvars",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &promptvars },
#if defined (RESTRICTED_SHELL)
  { "restricted_shell",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &restricted_shell,		.set_func = set_restricted_shell },
#endif
  { "shift_verbose",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &print_shift_error },
  { "sourcepath",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &source_uses_path },
#if defined (SYSLOG_HISTORY) && defined (SYSLOG_SHOPT)
  { "syslog_history",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &syslog_history },
#endif
  { "varredir_close",		.hide_set_o = true,	.adjust_bashopts = true,	.store = &varassign_redir_autoclose },
  { "xpg_echo",			.hide_set_o = true,	.adjust_bashopts = true,	.store = &xpg_echo },
};

static const char * const on = "on";
static const char * const off = "off";

static int change_shopts (int, WORD_LIST *, int);
static void print_shopt (char const*, int, int);
static int list_shopts (WORD_LIST *, int);
static int list_some_shopts (int, int);
static int list_shopt_o_options (WORD_LIST *, int);
static int list_some_o_options (int, int);
static int set_shopt_o_options (int, WORD_LIST *, int);

#define SFLAG	0x01
#define UFLAG	0x02
#define QFLAG	0x04
#define OFLAG	0x08
#define PFLAG	0x10

int
shopt_builtin (WORD_LIST *list)
{
  int opt, flags, rval;

  flags = 0;
  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "psuoq")) != -1)
    {
      switch (opt)
	{
	case 's':
	  flags |= SFLAG;
	  break;
	case 'u':
	  flags |= UFLAG;
	  break;
	case 'q':
	  flags |= QFLAG;
	  break;
	case 'o':
	  flags |= OFLAG;
	  break;
	case 'p':
	  flags |= PFLAG;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if ((flags & (SFLAG|UFLAG)) == (SFLAG|UFLAG))
    {
      builtin_error (_("cannot set and unset shell options simultaneously"));
      return (EXECUTION_FAILURE);
    }

  rval = EXECUTION_SUCCESS;
  if ((flags & OFLAG) && ((flags & (SFLAG|UFLAG)) == 0))	/* shopt -o */
    rval = list_shopt_o_options (list, flags);
  else if (list && (flags & OFLAG))		/* shopt -so args */
    rval = set_shopt_o_options ((flags & SFLAG) ? FLAG_ON : FLAG_OFF, list, flags & QFLAG);
  else if (flags & OFLAG)	/* shopt -so */
    rval = list_some_o_options ((flags & SFLAG) ? 1 : 0, flags);
  else if (list && (flags & (SFLAG|UFLAG)))	/* shopt -su args */
    rval = change_shopts ((flags & SFLAG) ? SETOPT : UNSETOPT, list, flags & QFLAG);
  else if ((flags & (SFLAG|UFLAG)) == 0)	/* shopt [args] */
    rval = list_shopts (list, flags);
  else						/* shopt -su */
    rval = list_some_shopts ((flags & SFLAG) ? SETOPT : UNSETOPT, flags);
  return (rval);
}

/* Reset the options managed by `shopt' to the values they would have at
   shell startup.  Variables from xo_options. */
void
reset_shopt_options (void)
{
  autocd = cdable_vars = cdspelling = 0;
  check_hashed_filenames = CHECKHASH_DEFAULT;
  check_window_size = CHECKWINSIZE_DEFAULT;
  allow_null_glob_expansion = glob_dot_filenames = 0;
  no_exit_on_failed_exec = 0;
  expand_aliases = expaliases_flag = 0;
  extended_quote = 1;
  fail_glob_expansion = 0;
  glob_asciirange = GLOBASCII_DEFAULT;
  glob_star = 0;
  gnu_error_format = 0;
  hup_on_exit = 0;
  inherit_errexit = 0;
  interactive_comments = 1;
  lastpipe_opt = 0;
  localvar_inherit = localvar_unset = 0;
  mail_warning = 0;
  glob_ignore_case = match_ignore_case = 0;
  print_shift_error = 0;
  source_uses_path = promptvars = 1;
  bash_source_fullpath = 0;
  varassign_redir_autoclose = 0;
  singlequote_translations = 0;
  patsub_replacement = PATSUB_REPLACE_DEFAULT;

#if defined (JOB_CONTROL)
  check_jobs_at_exit = 0;
#endif

#if defined (EXTENDED_GLOB)
  extended_glob = extglob_flag = EXTGLOB_DEFAULT;
#endif
  glob_always_skip_dot_and_dotdot = 1;		/* new default as of bash-5.2 */

#if defined (ARRAY_VARS)
  expand_once_flag = array_expand_once = 0;
#endif

#if defined (HISTORY)
  literal_history = 0;
  force_append_history = 0;
  command_oriented_history = 1;
#endif

#if defined (SYSLOG_HISTORY)
#  if defined (SYSLOG_SHOPT)
  syslog_history = SYSLOG_SHOPT;
#  else
  syslog_history = 1;
#  endif /* SYSLOG_SHOPT */
#endif

#if defined (READLINE)
  complete_fullquote = 1;
  force_fignore = 1;
  hist_verify = history_reediting = 0;
  perform_hostname_completion = 1;
#  if DIRCOMPLETE_EXPAND_DEFAULT
  dircomplete_expand = 1;
#  else
  dircomplete_expand = 0;
#endif
  dircomplete_spelling = 0;
  no_empty_command_completion = 0;
#endif

#if defined (PROGRAMMABLE_COMPLETION)
  prog_completion_enabled = 1;
#  if defined (ALIAS)
  progcomp_alias = 0;
#  endif
#endif

#if defined (DEFAULT_ECHO_TO_XPG) || defined (STRICT_POSIX)
  xpg_echo = 1;
#else
  xpg_echo = 0;
#endif /* DEFAULT_ECHO_TO_XPG */

#if defined (DEBUGGER)
  debugging_mode = 0;
#endif
}

static void
shopt_error (char const*s)
{
  builtin_error (_("%s: invalid shell option name"), s);
}

static int
change_shopts (int mode, WORD_LIST *list, int quiet)
{
  WORD_LIST *l;
  int rval;
  SHELL_VAR *v;

  for (l = list, rval = EXECUTION_SUCCESS; l; l = l->next)
    {
      char const*name = l->word->word;
      opt_def_t const *d = find_option (name);
      if (! d)
	{
	  shopt_error (name);
	  rval = EXECUTION_FAILURE; /* TODO: maybe EX_BADUSAGE ? */
	}
      else
	{
	  op_result_t r = set_opt_value (d, Accessor (shopt), mode);
	  if (! GoodResult (r))
	    rval = EXECUTION_FAILURE;
	}
    }

  /* Don't set $BASHOPTS here if it hasn't already been initialized */
  if (find_variable ("BASHOPTS"))
    set_bashopts ();
  return (rval);
}

static void
print_shopt (char const*name, int val, int flags)
{
  if (flags & PFLAG)
    printf ("shopt %s %s\n", val ? "-s" : "-u", name);
  else
    printf (OPTFMT, name, val ? on : off);
}

/* List the values of all or any of the `shopt' options.  Returns 0 if
   all were listed or all variables queried were on; 1 otherwise. */
static int
list_shopts (WORD_LIST *list, int flags)
{
  WORD_LIST *l;
  int rval = EXECUTION_SUCCESS;

  if (list == 0)
    {
      if ((flags & QFLAG) == 0)
	{
	  opt_def_t const *d;
	  for_each_option_class (d, Accessor (shopt))
	    print_shopt (d->name, get_opt_value (d, Accessor (shopt)), flags);
	}
    }
  else
    for (l = list, rval; l; l = l->next)
      {
	char const*name = l->word->word;
	opt_def_t const *d = find_option (name);
	if (! d)
	  {
	    shopt_error (name);
	    rval = EXECUTION_FAILURE;
	    continue;
	  }
	int val = get_opt_value (d, Accessor (shopt));
	if (val == 0)
	  rval = EXECUTION_FAILURE;
	if ((flags & QFLAG) == 0)
	  print_shopt (name, val, flags);
      }
  return (sh_chkwrite (rval));
}

static int
list_some_shopts (int mode, int flags)
{
  opt_def_t const *d;
  for_each_option_class (d, Accessor (shopt))
    {
      int val = get_opt_value (d, Accessor (shopt));
      if (((flags & QFLAG) == 0) && mode == val)
	print_shopt (d->name, val, flags);
    }
  return (sh_chkwrite (EXECUTION_SUCCESS));
}

static int
list_shopt_o_options (WORD_LIST *list, int flags)
{
  WORD_LIST *l;
  int val, rval;

  if (list == 0)
    {
      if ((flags & QFLAG) == 0)
	list_minus_o_opts (-1, (flags & PFLAG));
      return (sh_chkwrite (EXECUTION_SUCCESS));
    }

  for (l = list, rval = EXECUTION_SUCCESS; l; l = l->next)
    {
      val = minus_o_option_value (l->word->word);
      if (val == -1)
	{
	  sh_invalidoptname (l->word->word);
	  rval = EXECUTION_FAILURE;
	  continue;
	}
      if (val == 0)
	rval = EXECUTION_FAILURE;
      if ((flags & QFLAG) == 0)
	{
	  if (flags & PFLAG)
	    printf ("set %co %s\n", val ? '-' : '+', l->word->word);
	  else
	    printf (OPTFMT, l->word->word, val ? on : off);
	}
    }
  return (sh_chkwrite (rval));
}

static int
list_some_o_options (int mode, int flags)
{
  if ((flags & QFLAG) == 0)
    list_minus_o_opts (mode, (flags & PFLAG));
  return (sh_chkwrite (EXECUTION_SUCCESS));
}

static int
set_shopt_o_options (int mode, WORD_LIST *list, int quiet)
{
  WORD_LIST *l;
  int rval;

  for (l = list, rval = EXECUTION_SUCCESS; l; l = l->next)
    {
      if (set_minus_o_option (mode, l->word->word) == EXECUTION_FAILURE)
	rval = EXECUTION_FAILURE;
    }
  set_shellopts ();
  return rval;
}

/* If we set or unset interactive_comments with shopt, make sure the
   change is reflected in $SHELLOPTS. */
static op_result_t
set_shellopts_after_change (opt_def_t const *d, accessor_t why, int mode)
{
  d->store[0] = mode;
  set_shellopts ();
  return Result (OK);
}

static op_result_t
shopt_set_debug_mode (opt_def_t const *d, accessor_t why, int mode)
{
  d->store[0] = mode;
#if defined (DEBUGGER)
  error_trace_mode = function_trace_mode = debugging_mode;
  set_shellopts ();
  if (debugging_mode)
    init_bash_argv ();
#endif
  return Result (OK);
}

static op_result_t
shopt_set_expaliases (opt_def_t const *d, accessor_t why, int mode)
{
  d->store[0] = mode;
  expand_aliases = expaliases_flag;
  return Result (OK);
}

#if defined (EXTENDED_GLOB)
static op_result_t
shopt_set_extglob (opt_def_t const *d, accessor_t why, int mode)
{
  d->store[0] = mode;
  extended_glob = extglob_flag;
  return Result (OK);
}
#endif

#if defined (READLINE)
static op_result_t
shopt_enable_hostname_completion (opt_def_t const *d, accessor_t why, int mode)
{
  d->store[0] = mode;
  enable_hostname_completion (mode);
  return Result (OK);
}
#endif

static op_result_t
set_compatibility_level (opt_def_t const *d, accessor_t why, int mode)
{
  if (mode)
    shell_compatibility_level = d->reference_value;
  else if (shell_compatibility_level == d->reference_value)
    shell_compatibility_level = DEFAULT_COMPAT_LEVEL;
  else
    return Result (Ignored);

  /* Make sure the current compatibility level is reflected in BASH_COMPAT */
  char *rhs = itos (shell_compatibility_level);
  bind_variable ("BASH_COMPAT", rhs, 0);
  free (rhs);

  return Result (OK);
}

static option_value_t
get_compatibility_level (opt_def_t const *d, accessor_t why)
{
  return shell_compatibility_level == d->reference_value;
}

/* Set and unset the various compatibility options from the value of
   shell_compatibility_level; used by sv_shcompat
   TODO - no longer required */
void
set_compatibility_opts (void)
{
}

#if defined (READLINE)
static op_result_t
shopt_set_complete_direxpand (opt_def_t const *d, accessor_t why, int mode)
{
  d->store[0] = mode;
  set_directory_hook ();
  return Result (OK);
}
#endif

#if defined (RESTRICTED_SHELL)
/* Don't allow the value of restricted_shell to be modified. */

static op_result_t
set_restricted_shell (opt_def_t const *d, accessor_t why, int mode)
{
  d->store[0] = mode;

  static int save_restricted = -1;

  if (save_restricted == -1)
    save_restricted = shell_is_restricted (shell_name);

  restricted_shell = save_restricted;
  return Result (OK);
}
#endif /* RESTRICTED_SHELL */

/* Not static so shell.c can call it to initialize shopt_login_shell */
int
set_login_shell (char *option_name, int mode)
{
  return (0);
}

char **
get_shopt_options (void)
{
  size_t n = count_options_class (Accessor (shopt));
  char **ret = strvec_create (n + 1);
  opt_def_t const *d;
  size_t i = 0;
  for_each_option_class (d, Accessor (shopt))
    ret[i++] = savestring (d->name);
  ret[i] = NULL;
  return ret;
}

/*
 * External interface for other parts of the shell.  NAME is a string option;
 * MODE is 0 if we want to unset an option; 1 if we want to set an option.
 * REUSABLE is 1 if we want to print output in a form that may be reused.
 */
int
shopt_setopt (char const *name, int mode)
{
  WORD_LIST *wl;
  int r;

  wl = add_string_to_list (name, (WORD_LIST *)NULL);
  r = change_shopts (mode, wl, 0);
  dispose_words (wl);
  return r;
}

int
shopt_listopt (char const *name, int reusable)
{
  int i;

  if (name == 0)
    return (list_shopts ((WORD_LIST *)NULL, reusable ? PFLAG : 0));

  opt_def_t const *d = find_option (name);
  if (! d)
    {
      shopt_error (name);
      return (EXECUTION_FAILURE);
    }

  print_shopt (name, get_opt_value (d, Accessor (shopt)), reusable ? PFLAG : 0);
  return (sh_chkwrite (EXECUTION_SUCCESS));
}

void
set_bashopts (void)
{
  size_t count = count_options ();
  char *tflag = xmalloc (count + 1);

  size_t vsize = 0;
  {
    size_t i = 0;
    opt_def_t const *d;
    for_each_option_class (d, Accessor (shopt))
      {
	int val = get_opt_value (d, Accessor (env_bashopts));
	tflag[i++] = val;
	if (val)
	  vsize += strlen (d->name) + 1;
      }
  }

  char const *value;

  {
    char *vend = xmalloc (vsize + 1);
    value = vend;
    size_t i = 0;
    opt_def_t const *d;
    for_each_option_class (d, Accessor (shopt))
      if (tflag[i++])
	{
	  vend = stpcpy (vend, d->name);
	  *vend++ = ':';
	}
    if (vend > value)
      vend--;			/* cut off trailing colon */
    *vend = '\0';
  }

  xfree (tflag);

  /* ASS_FORCE so we don't have to temporarily turn off readonly;
   * ASS_NOMARK so we don't tickle `set -a`. */
  SHELL_VAR *var = bind_variable ("BASHOPTS", value, ASS_FORCE | ASS_NOMARK);
  free (value);

  /* Turn the read-only attribute back on. */
  VSETATTR (var, att_readonly);
}

static void
parse_bashopts (char const*value)
{
  char const*vname;
  int vptr;

  vptr = 0;
  while (vname = extract_colon_unit (value, &vptr))
    {
      opt_def_t const *d = find_option (vname);
      if (d)
	set_opt_value(d, Accessor (env_bashopts), true);
      free (vname);
    }
}

void
initialize_bashopts (int no_bashopts)
{
  char *temp;
  SHELL_VAR *var;

  if (no_bashopts == 0)
    {
      var = find_variable ("BASHOPTS");
      /* set up any shell options we may have inherited. */
      if (var && imported_p (var))
	{
	  temp = (array_p (var) || assoc_p (var)) ? (char *)NULL : savestring (value_cell (var));
	  if (temp)
	    {
	      parse_bashopts (temp);
	      free (temp);
	    }
	}
    }

  /* Set up the $BASHOPTS variable. */
  set_bashopts ();
}

#if defined (ARRAY_VARS)
static op_result_t
set_array_expand (opt_def_t const *d, accessor_t why, int mode)
{
  d->store[0] = mode;
#if 0 /* leave this disabled */
  if (shell_compatibility_level <= 51)
#endif
    array_expand_once = expand_once_flag;
  return Result (OK);
}
#endif

void
register_shopt_opts (void)
{
  for (size_t i = 0 ; i < (sizeof (xo_options) / sizeof (xo_options[0])) ; ++i)
    register_option (&xo_options[i]);
}
