This file is shopt.def, from which is created shopt.c.
It implements the Bash `shopt' builtin.

Copyright (C) 1994-2024 Free Software Foundation, Inc.

This file is part of GNU Bash, the Bourne Again SHell.

Bash is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Bash is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Bash.  If not, see <http://www.gnu.org/licenses/>.

$PRODUCES shopt.c

$BUILTIN shopt
$FUNCTION shopt_builtin
$SHORT_DOC shopt [-oOpP] [-q] [-su] [OPTNAME ...]
shopt [-oOpP] [-q] [-su] [OPTNAME ...]
shopt [--list-options | --option-help | --option-usage | -[fhH] ] [OPTNAME ...]
Display or change shell options.

If one or more OPTNAMEs is given, and one of "-s" or "-u" is given, and neither
"-p" nor "-P" is given, then the named options will be set (if "-s" is given)
or unset (if "-u" is given).

Otherwise "shopt" will display options. Initially all options are candidates
for display, but:
 - if "-o" is given, limit the display to only those candidates defined for use
   with "set -o"; if "-O" is given make the inverse limitation.
 - if "-s" is given, limit the display to only "set"/"on" candidates
 - if "-u" is given, limit the display to only "unset"/"off" candidates
 - if OPTNAMEs are given, limit the display to those candidates that are among
   the OPTNAMEs.

Options:
  -o	restrict OPTNAMEs to those defined for use with "set -o"
  -O	restrict OPTNAMEs to those not defined for use with "set -o"
  -p, -P
	Display each shell option in a form that can be re-used as shell input
	-P	output as "shopt" commands
	-Pp	output as "set -o" commands
	-p	output as "set -o" commands if "-o" is also given;
		output as "shopt" commands if "-o" is not given.
	Otherwise show each option name with 'on' or 'off'.
  -q	Suppress output (only return exit status)
  -s	Enable (set) each OPTNAME (or limit output with -p or -P)
  -u	Disable (unset) each OPTNAME (or limit output with -p or -P)

Exit Status:
Returns success if all OPTNAMEs are enabled; fails if an invalid option is
given or if any OPTNAME is disabled.

Type "shopt --list-options" to see a brief list of options.
Type "shopt --option-help [OPTNAME ...]" to see short help for each option.
Type "shopt --option-usage [OPTNAME ...]" to see detailed help for each option.
$END

#include <config.h>

#if defined (HAVE_UNISTD_H)
#  ifdef _MINIX
#    include <sys/types.h>
#  endif
#  include <unistd.h>
#endif

#include <stdio.h>

#include "version.h"

#include "../bashintl.h"
#include "../parser.h"

#include "../shell.h"
#include "../flags.h"
#include "../options.h"

#include "../execute_cmd.h"

#include "common.h"
#include "bashgetopt.h"

#if defined (READLINE)
#  include "../bashline.h"
#  include <readline/readline.h>
#endif

#if defined (HISTORY)
#  include "../bashhist.h"
#endif

extern int allow_null_glob_expansion;
extern int cdspelling;
extern int check_hashed_filenames;
extern int check_jobs_at_exit;
extern int check_window_size;
extern int expand_aliases;
extern int extended_quote;
extern int fail_glob_expansion;
extern int glob_always_skip_dot_and_dotdot;
extern int glob_asciirange;
extern int glob_dot_filenames;
extern int glob_ignore_case;
extern int glob_star;
extern int gnu_error_format;
extern int hup_on_exit;
extern int inherit_errexit;
extern int lastpipe_opt;
extern int localvar_inherit;
extern int localvar_unset;
extern int mail_warning;
extern int match_ignore_case;
extern int no_exit_on_failed_exec;
extern int patsub_replacement;
extern int print_shift_error;
extern int promptvars;
extern int singlequote_translations;
extern int source_uses_path;
extern int varassign_redir_autoclose;
extern int xpg_echo;

#if defined (EXTENDED_GLOB)
extern int extended_glob;
#endif

#if defined (READLINE)
extern int complete_fullquote;
extern int dircomplete_expand;
extern int dircomplete_spelling;
extern int force_fignore;
extern int hist_verify;
extern int history_reediting;
extern int no_empty_command_completion;
extern int perform_hostname_completion;

extern int enable_hostname_completion (int);
#endif

#if defined (PROGRAMMABLE_COMPLETION)
extern int prog_completion_enabled;
extern int progcomp_alias;
#endif

#if defined (DEBUGGER)
extern int debugging_mode;
#endif

#if defined (ARRAY_VARS)
extern int array_expand_once;
#endif

#if defined (SYSLOG_HISTORY)
extern int syslog_history;
#endif

static void shopt_error (char const*);

static opt_get_func_t get_compatibility_level;
static opt_set_func_t set_compatibility_level;

#if defined (RESTRICTED_SHELL)
static opt_set_func_t set_restricted_shell;
#endif

#if defined (READLINE)
static opt_set_func_t shopt_enable_hostname_completion;
static opt_set_func_t shopt_set_complete_direxpand;
#endif

#if defined (EXTENDED_GLOB)
int extglob_flag = EXTGLOB_DEFAULT;
static opt_set_func_t shopt_set_extglob;
#endif

int expaliases_flag = 0;
static opt_set_func_t shopt_set_expaliases;

static opt_set_func_t shopt_set_debug_mode;

static int shopt_login_shell;

static opt_set_func_t set_ignoreeof;
static opt_set_func_t set_posix_mode;

#if defined (READLINE)
static opt_set_func_t set_edit_mode;
static opt_get_func_t get_edit_mode;
#endif

#if defined (HISTORY)
static opt_set_func_t set_history_flag;
#endif

/*
 * Keep aach option's terms in this order:
 *  Name, Letter
 *  Store (pointer)
 *  Init (pointer), Skip-reset
 *  Getter & Setter functions, Reference value
 *  Read-only, Forbid-change, Ignore-change
 *  (everything else in alphabetical order)
 *  Help
 */

static opt_def_t const xo_options[] = {
#if defined (ARRAY_VARS)
  { "array_expand_once",
    .store = &array_expand_once,
    .OPTRESET_false,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Suppress multiple evaluation of array subscripts during arithmetic\n"
      "expression evaluation, while executing builtins that perform variable\n"
      "assignments, or that perform array dereferencing."),
  },
  { "assoc_expand_once",
    .store = &array_expand_once,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .hide_shopt = true,
    .help = N_(
      "(Obsolete synonym for array_expand_once)"),
  },
#endif
  { "cdspell",
    .store = &cdspelling,
    .OPTRESET_false,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Minor errors (single transpositions, omissions, or insertions) in the\n"
      "spelling of a directory component in a cd command will be corrected.\n"
      "(Interactive only.)"),
  },
  { "checkhash",
    .store = &check_hashed_filenames,
    .init = &(option_value_t const){CHECKHASH_DEFAULT},
    .skip_reinit = true,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Check that a command found in the hash table exists before trying to\n"
      "execute it. If a hashed command no longer exists, a normal path search\n"
      "is performed.\n"
      "(See hashall)"),
  },
#if defined (JOB_CONTROL)
  { "checkjobs",
    .store = &check_jobs_at_exit,
    .OPTRESET_false,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Check running jobs (not just stopped ones) when hesitating to exit"),
  },
#endif
  { "checkwinsize",
    .store = &check_window_size,
    .init = &(option_value_t const){CHECKWINSIZE_DEFAULT},
    .skip_reinit = true,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Check the window size after each external (non-builtin) command and, if\n"
      "necessary, updates the values of LINES and COLUMNS."),
  },
#if defined (HISTORY)
  { "cmdhist",
    .store = &command_oriented_history,
    .OPTRESET_true,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Multi-line commands are recorded as single history lines, with semicolons\n"
      "inserted as needed."),
  },
#endif
  { "compat31",
    .set_func = set_compatibility_level,
    .get_func = get_compatibility_level,
    .reference_value = 31,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Disable some changes made after Bash v3.1\n"
      " ‧ v3.1 Strip quotes from PATTERN in [[ WORD =~ PATTERN ]]\n"
      "        \n"
      " ‧ v3.2 Don't strip quotes from PATTERN in [[ WORD =~ PATTERN ]]"),
  },
  { "compat32",
    .set_func = set_compatibility_level,
    .get_func = get_compatibility_level,
    .reference_value = 32,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Disable some changes made after Bash v3.2\n"
      "(See compat40 for subsequent changes; see compat31 for prior changes)"),
  },
  { "compat33",
    .set_func = set_compatibility_level,
    .get_func = get_compatibility_level,
    .reference_value = 33,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Disable some changes made after Bash v3.3\n"
      "(See compat40 for subsequent changes; see compat31 for prior changes)"),
  },
  { "compat40",
    .set_func = set_compatibility_level,
    .get_func = get_compatibility_level,
    .reference_value = 40,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Disable some changes made after Bash v4.0\n"
      " ‧ v4.0 [[ A < B ]] collation is always ASCII\n"
      " ‧ v4.1 [[ A < B ]] collation may use current locale"),
  },
  { "compat41",
    .set_func = set_compatibility_level,
    .get_func = get_compatibility_level,
    .reference_value = 41,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Disable some changes made after Bash v4.1\n"
      " ‧ v4.1 In POSIX mode, recognize 'time' keyword even when followed by options.\n"
      "        Do not interpret nested quotes within ${VAR//PATTERN/REPLACE}\n"
      " ‧ v4.2 Adhere to Austin Group interpretations 267 (POSIX 2008)\n"
      "        Only recognize 'time' keyword when not followed by options\n"
      "        Apply anomalous intermediate nested quotes rule; see 'compat42'."),
  },
  { "compat42",
    .set_func = set_compatibility_level,
    .get_func = get_compatibility_level,
    .reference_value = 42,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Disable some changes made after Bash v4.2\n"
      " ‧ v4.1 Do not interpret nested quotes within '${VAR//PATTERN/REPLACE}';\n"
      " ‧ v4.2 Apply anomalous intermediate nested quotes rule;\n"
      " ‧ v4.3 Adhere to Austin Group interpretations 221 (POSIX 2008)\n"
      "        Interpret matching nested quotes within '${VAR//PATTERN/REPLACE}'."),
  },
  { "compat43",
    .set_func = set_compatibility_level,
    .get_func = get_compatibility_level,
    .reference_value = 43,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Disable some changes made after Bash v4.3\n"
      " ‧ v4.3 ...\n"
      " ‧ v4.4 ..."),
  },
  { "compat44",
    .set_func = set_compatibility_level,
    .get_func = get_compatibility_level,
    .reference_value = 44,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Disable some changes made after Bash v4.4\n"
      " ‧ v4.4 ...\n"
      " ‧ v5.0 ..."),
  },
  { "compat50",
    .set_func = set_compatibility_level,
    .get_func = get_compatibility_level,
    .reference_value = 50,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .hide_shopt = true,
    .help = N_(
      "Disable some changes made after Bash v5.0\n"
      " ‧ v5.0 'unset ARRAY[@]' unsets the whole array,\n"
      " ‧ v5.1 'unset ARRAY[@]' removes all elements"),
  },
  { "compat51",
    .set_func = set_compatibility_level,
    .get_func = get_compatibility_level,
    .reference_value = 51,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .hide_shopt = true,
    .help = N_(
      "Disable some changes made after Bash v5.1\n"
      " ‧ v5.1 Expand array indices twice\n"
      " ‧ v5.2 Improve handling of array subscripts in numeric context."),
  },
  { "compat52",
    .set_func = set_compatibility_level,
    .get_func = get_compatibility_level,
    .reference_value = 52,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .hide_shopt = true,
    .help = N_(
      "Disable some changes made after Bash v5.2\n"
      " ‧ v5.2 ...\n"
      " ‧ v5.3 ..."),
  },
  { "compat53",
    .set_func = set_compatibility_level,
    .get_func = get_compatibility_level,
    .reference_value = 53,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .hide_shopt = true,
    .help = N_(
      "Disable some changes made after Bash v5.3\n"
      "(Future changes are not yet known.)"),
  },
  { "compat54",
    .set_func = set_compatibility_level,
    .get_func = get_compatibility_level,
    .reference_value = 54,
    .readonly = true,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .hide_shopt = true,
    .help = N_(
      "Disable some changes made after Bash v5.4\n"
      "(Features added by this future version of Bash are unavailable.)"),
  },
#if defined (READLINE)
  { "complete_fullquote",
    .store = &complete_fullquote,
    .OPTRESET_true,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Quote '$' in tab-completion results."),
  },
  { "direxpand",
    .store = &dircomplete_expand,
    .set_func = shopt_set_complete_direxpand,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Replaces directory names with the results of word expansion when\n"
      "performing filename completion, within the readline editing buffer.\n"
      "If not set, attempt to preserve what the user typed."),
  },
  { "dirspell",
    .store = &dircomplete_spelling,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Attempt spelling correction on directory names during word completion if\n"
      "the directory name initially supplied does not exist.\n"
      "(Same as cdspell but applied to completions.)"),
  },
#endif
  { "dotglob",
    .store = &glob_dot_filenames,
    .OPTRESET_false,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Include filenames beginning with a '.' in the results of pathname\n"
      "expansion. (See GLOBIGNORE, globskipdots, & nocaseglob.)"),
  },
#if defined (READLINE)
  { "emacs",
    .set_func = set_edit_mode,
    .get_func = get_edit_mode,
    .reference_value = EMACS_EDITING_MODE,
    .adjust_shellopts = true,
    .hide_shopt = true,
    .help = N_(
      "Use an emacs-style line editing interface"),
  },
#endif
  { "execfail",
    .store = &no_exit_on_failed_exec,
    .OPTRESET_false,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Do not exit when the 'command' argument to the 'exec' built-in cannot be\n"
      "executed. (Always applies to interactive shells.)"),
  },
  { "expand_aliases",
    .store = &expaliases_flag,
    .set_func = shopt_set_expaliases,
    .OPTRESET_REINIT_false,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Expand aliases that appear where a simple command is expected.\n"
      "(Off by default for scripts.)")
  },
#if defined (DEBUGGER)
  { "extdebug",
    .store = &debugging_mode,
    .set_func = shopt_set_debug_mode,
    .OPTRESET_REINIT_false,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "If set in a shell startup file, or by the --debugger option at startup,\n"
      "arrange to execute the debugger profile before the shell starts.\n"
      "If set after invocation, behavior intended for use by debuggers is\n"
      "enabled, especially filename and line number being included:\n"
      " ‧ in BASH_ARGC and BASH_ARGV\n"
      " ‧ in the output of 'declare -F' & 'caller'\n"
      "The DEBUG, ERR, & RETURN traps are inherited by functions and subshells."),
  },
#endif
#if defined (EXTENDED_GLOB)
  { "extglob",
    .store = &extglob_flag,
    .set_func = shopt_set_extglob,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Enable extended pattern matching.\n"
      "Extended pattern matching always applies to [[ WORD = PATTERN ]]\n"
      "unless compat40 (or earlier) is enabled."),
  },
#endif
  { "extquote",
    .store = &extended_quote,
    .OPTRESET_true,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Expand $'string' and $\"string\" quoting within ${parameter} expansions\n"
      "even when enclosed in double quotes."),
  },
  { "failglob",
    .store = &fail_glob_expansion,
    .OPTRESET_false,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Pathname expansion applied to patterns that fail to match any filenames\n"
      "results in an expansion error. (This may result in undesired behaviour in\n"
      "commands like `ls` that interpret \"no arguments\" specially.)"),
  },
#if defined (READLINE)
  { "force_fignore",
    .store = &force_fignore,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Suffixes specified in FIGNORE cause words to be ignored when performing\n"
      "word completion even if these are the only possible completions."),
  },
#endif
  { "globasciiranges",
    .store = &glob_asciirange,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Range expressions like '[a-z]' in pattern matching expressions behave as\n"
      "if in the traditional 'C' locale, so 'b' will not match '[A-Z]'."),
  },
  { "globskipdots",
    .store = &glob_always_skip_dot_and_dotdot,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Globbing will never match the directory names '.' and '..', even if the\n"
      "pattern begins with a '.'."),
  },
  { "globstar",
    .store = &glob_star,
    .OPTRESET_false,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "When a filename glob starts with `**/` or contains `/**/`, it will\n"
      "recursively match the remainder of the pattern in all subdirectories. When\n"
      "a filename glob ends with `/**` (or is entirely `**`), it will recursively\n"
      "match all files in all subdirectories. The behaviour of `**` when not\n"
      "bounded by `/` is unspecified, and subject to change.")
  },
  { "gnu_errfmt",
    .store = &gnu_error_format,
    .OPTRESET_false,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Shell error messages are written in the standard GNU error message format."),
  },
#if defined (HISTORY)
  { "histappend",
    .store = &force_append_history,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "When the shell exits, history will be appended to the shell history file,\n"
      "rather than overwriting it. (See HISTFILE.)"),
  },
#endif
#if defined (HISTORY)
  { "history",
    .store = &enable_history_list,
    .OPTRESET_true,
    .set_func = set_history_flag,
    .adjust_shellopts = true,
    .hide_shopt = true,
    .help = N_(
      "Enable command history"),
  },
#endif
#if defined (READLINE)
  { "histreedit",
    .store = &history_reediting,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "The original text of each failed history substitution is placed in the\n"
      "readline input buffer, allowing the user to confirm, amend, or cancel it.\n"
      "(Only effective if readline is also active.)"),
  },
  { "histverify",
    .store = &hist_verify,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "The resulting text of each successful history substitutions are placed in\n"
      "the readline input buffer, allowing the user to confirm, amend, or cancel\n"
      "it. (Only effective if readline is also active.)"),
  },
  { "hostcomplete",
    .store = &perform_hostname_completion,
    .set_func = shopt_enable_hostname_completion,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Attempt to perform hostname completion when attempting completion on a\n"
      "word containing '@'. (Only effective if readline is also active.)\n"),
  },
#endif
  { "huponexit",
    .store = &hup_on_exit,
    .OPTRESET_false,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Send SIGHUP to all jobs when an interactive login shell exits."),
  },
  { "ignoreeof",
    .store = &ignoreeof,
    .OPTRESET_false,
    .set_func = set_ignoreeof,
    .adjust_shellopts = true,
    .hide_shopt = true,
    .help = N_(
      "Do not immediately exit upon reading EOF"),
  },
  { "inherit_errexit",
    .store = &inherit_errexit,
    .OPTRESET_false,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Command substitution subshells inherit the value of the 'errexit' option.\n"
      "(Enabled when posix mode is enabled.)"),
  },
  { "interactive-comments",
    .store = &interactive_comments,
    .adjust_bashopts = true,
    .adjust_shellopts = true,
    .hide_shopt = true,
    .help = N_(
      "(see interactive_comments)"),
  },
  { "interactive_comments",
    .store = &interactive_comments,
    .OPTRESET_REINIT_true,
    .adjust_bashopts = true,
    .adjust_shellopts = true,
    .hide_set_o = true,
    .help = N_(
      "Allow a word beginning with '#' to cause that word and all remaining\n"
      "characters on that line to be ignored in an interactive shell."),
  },
  { "lastpipe",
    .store = &lastpipe_opt,
    .OPTRESET_false,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Runs the last command of a pipeline (not executed in the background) in\n"
      "the current shell environment. (Not effective if job control is active.)"),
  },
#if defined (HISTORY)
  { "lithist",
    .store = &literal_history,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Modifies the behaviour of the 'cmdhist' option to write newlines rather\n"
      "than semicolons."),
  },
#endif
  { "localvar_inherit",
    .store = &localvar_inherit,
    .OPTRESET_false,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Local variables inherit the value and attributes of a variable with the\n"
      "same name in a previous scope, before any new value is assigned.\n"
      "(The nameref attribute is not inherited.)"),
  },
  { "localvar_unset",
    .store = &localvar_unset,
    .OPTRESET_false,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Calling 'unset' on local variables in previous function scopes marks them\n"
      "so that subsequent lookups find them unset until that function returns.\n"
      "This is identical to the behavior of unsetting local variables at the\n"
      "current function scope."),
  },
  { "login_shell",
    .store = &login_shell,
    .ignore_change = true,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Indicates whether this shell was started as a login shell, either by using\n"
      "the '-l' option or by modifying argv[0]."),
  },
  { "mailwarn",
    .store = &mail_warning,
    .OPTRESET_false,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "If a file that bash is checking for mail has been accessed since the last\n"
      "time it was checked, bash displays a message like\n"
      " \"The mail in <name-of-mailfile> has been read\"."),
  },
#if defined (READLINE)
  { "no_empty_cmd_completion",
    .store = &no_empty_command_completion,
    .OPTRESET_false,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Do not search $PATH for possible completions when completion is attempted\n"
      "on an empty line. (Only if readline is active.)"),
  },
#endif
  { "nocaseglob",
    .store = &glob_ignore_case,
    .OPTRESET_false,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Match filenames case-insensitively when performing pathname expansion."),
  },
  { "nocasematch",
    .store = &match_ignore_case,
    .OPTRESET_false,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Match patterns case-insensitively when performing matching for 'case' or\n"
      "'[[' commands, when performing pattern substitution word expansions, or\n"
      "when filtering possible completions as part of programmable completion."),
  },
  { "noexpand_translation",
    .store = &singlequote_translations,
    .OPTRESET_false,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Treat the translated results of $\"...\" as if single quoted rather than\n"
      "double quoted. (No effect if the string is not translated.)"),
  },
#if defined (HISTORY)
  { "nolog",
    .store = &dont_save_function_defs,
    .OPTRESET_false,
    .adjust_shellopts = true,
    .hide_shopt = true,
    .help = N_(
      "(currently accepted but ignored)"),
  },
#endif
  { "nullglob",
    .store = &allow_null_glob_expansion,
    .OPTRESET_false,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Pathname expansions that match no filenames expand to no words, rather\n"
      "than expanding to themselves."),
  },
  { "patsub_replacement",
    .store = &patsub_replacement,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "In ${VAR/PATTERN/REPLACEMENT} expansions, expand occurrences of '&' in\n"
      "REPLACEMENT to the text matched by PATTERN."),
  },
  { "pipefail",
    .store = &pipefail_opt,
    .OPTRESET_REINIT_false,
    .adjust_shellopts = true,
    .hide_shopt = true,
    .help = N_(
      "Make the exit status of a pipeline be the last non-zero exit status of any of\n"
      "its components, or zero if the status of every component is zero.\n"
      "(Otherwise use the exit status of its right-most component.)"),
  },
  { "posix",
    .store = &posixly_correct,
#if defined (STRICT_POSIX)
    .OPTRESET_true,
#else
    .OPTRESET_false,
#endif
    .set_func = set_posix_mode,
    .adjust_shellopts = true,
    .hide_shopt = true,
    .help = N_(
      "Disable most behaviours that deviate from what is permitted or required by\n"
      "the POSIX (IEEE-1003.1-2024) standard.")
  },
#if defined (PROGRAMMABLE_COMPLETION)
  { "progcomp",
    .store = &prog_completion_enabled,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Enable programmable tab-completion."),
  },
#  if defined (ALIAS)
  { "progcomp_alias",
    .store = &progcomp_alias,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "When completion on a command name doesn't result in any matches, look for\n"
      "a possible matching aliases instead."),
  },
#  endif
#endif
  { "promptvars",
    .store = &promptvars,
    .OPTRESET_true,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "After being expanded, prompt strings ($PS0 through $PS4) undergo parameter\n"
      "expansion, command substitution, arithmetic expansion, and another round\n"
      "of quote removal."),
  },
#if defined (RESTRICTED_SHELL)
  { "restricted_shell",
    .store = &restricted_shell,
    .set_func = set_restricted_shell,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Indicates whether this shell was started as a restricted shell, either by\n"
      "using the '-r' option or by modifying argv[0]."),
  },
#endif
  { "shift_verbose",
    .store = &print_shift_error,
    .OPTRESET_false,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Causes the shift builtin to print an error message when the shift count\n"
      "exceeds the number of positional parameters."),
  },
  { "sourcepath",
    .store = &source_uses_path,
    .OPTRESET_true,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "The '.' (source) builtin searches $PATH to locate the file supplied as its\n"
      "first argument. (On by default; ignored when the '-p' option is given.)"),
  },
#if defined (SYSLOG_HISTORY) && defined (SYSLOG_SHOPT)
  { "syslog_history",
    .store = &syslog_history,
    .init = &(option_value_t const){SYSLOG_SHOPT},
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Immediately write each history entry to the syslog facility"),
  },
#endif
  { "varredir_close",
    .store = &varassign_redir_autoclose,
    .OPTRESET_false,
    .adjust_bashopts = true,
    .hide_set_o = true,
    .help = N_(
      "Automatically closes file descriptors assigned using the {VARNAME}>PATH\n"
      "redirection syntax, instead of leaving them open when the command\n"
      "completes."),
  },
#if defined (READLINE)
  { "vi",
    .set_func = set_edit_mode,
    .get_func = get_edit_mode,
    .reference_value = VI_EDITING_MODE,
    .adjust_shellopts = true,
    .hide_shopt = true,
    .help = N_(
      "Use a vi-style line editing interface"),
  },
#endif
};

/*
 * By default, show *all* options (both shopt and set -o), using the 'standard' format.
 * Otherwise:
 *  Selection:
 *  ‧ `-o` only show classic `set -o` options
 *  ‧ `-O` don't show classic `set -o` options
 *  ‧ (otherwise show all)
 *  Format:
 *  ‧ `-po` or `-Pp` use `set -o` reusable format
 *  ‧ `-p`  or `-P`  use `shopt` reusable format
 *  ‧ (otherwise use 'standard' format)
 *  (The intention is that `-P` is like `-p` but insensitive to whether `-o`
 *   has been used to select the classic `set -o` subset; for completeness,
 *   using both `-Pp` uses the `set -o` format without limiting the selection.)
 * Note that --short-help and --long-help are simply treated as
 * "display" with a funny display style.
 */

static inline _Bool
match (char const *arg, char const *pattern, size_t min)
{
  size_t plen = strlen (pattern);
  if (min == 0 || min > plen)
    min = plen;
  size_t alen = strlen (arg);
  return min <= alen && alen <= plen
      && 0 == memcmp (arg, pattern, alen);
}

int
shopt_builtin (WORD_LIST *list)
{
  int help_level = 0;
  _Bool mode_O = false;
  _Bool mode_P = false;
  _Bool mode_o = false;
  _Bool mode_p = false;
  _Bool quiet = false;
  _Bool universal = false;
  _Bool value_s = false;
  _Bool value_u = false;

  /* Long options must come before short options ... */
  for (char const *arg; list && list->word && (arg = list->word->word) != NULL && arg[0] == '-' && arg[1] == '-' && arg[2] != 0 ;list = list->next)
    {
      if (match (arg, "--list-options", 3)) { help_level = 1; continue; }
      if (match (arg, "--options", 3) || match (arg, "--option-help", 10) || match (arg, "--help-options", 8)) { help_level = 2; continue; }
      if (match (arg, "--usage",   3) || match (arg, "--option-usage", 10)) { help_level = 3; continue; }
      builtin_usage ();
      return (EX_USAGE);
    }

  /* ... and short options must come before OPTNAMEs */
  reset_internal_getopt ();
  int opt;
  while ((opt = internal_getopt (list, "fHhoOpPqsSu")) != -1)
    {
      switch (opt)
	{
	case 'f': help_level = 3; break;
	case 'H': help_level = 2; break;
	case 'h': help_level = 1; break;
	case 'o': mode_o = true; break;	/* emulate set -o (both choice and format) */
	case 'O': mode_O = true; break;	/* inverse of -o choice */
	case 'p': mode_p = true; break;
	case 'P': mode_P = true; break;
	case 'q': quiet = true; break;
	case 's': value_s = true; break;
	case 'u': value_u = true; break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  accessor_t oc = mode_o ? Accessor (set_o) :
		  mode_O ? Accessor (shopt) :
			   Accessor (any);

  display_style_t ds = help_level > 0 ? DisplayStyle (help1-1+help_level) :
		 ! mode_p && ! mode_P ? DisplayStyle (on_off) :
		    (mode_P ? mode_p
			    : mode_o) ? DisplayStyle (set_o)
				      : DisplayStyle (shopt);

  unsigned int value_comb = value_s == value_u ? 0 : 1 << !value_s;

  int rval = EXECUTION_SUCCESS;
  if (list == NULL)
    {
      if (quiet == 0)
	list_all_options (oc, value_comb, ds);
    }
  else if (!(value_s || value_u) || mode_p || mode_P || help_level > 0)
    {
      for (WORD_LIST *l = list; l; l = l->next)
	{
	  char const*name = l->word->word;
	  opt_def_t const *d = find_option (name);
	  if (! d)
	    {
	      shopt_error (name);
	      rval = EXECUTION_FAILURE;
	      continue;
	    }
	  int val = get_opt_value (d, oc);
	  if (value_comb &&
	      value_comb & 1U << val)
	    continue;
	  if (val == 0)
	    rval = EXECUTION_FAILURE;
	  if (! quiet)
	    show_one_option (d, oc, ds);
	}
    }
  else
    {
      if (value_s && value_u)
	{
	  builtin_error (_("cannot set and unset shell options simultaneously"));
	  return (EXECUTION_FAILURE);
	}
      for (WORD_LIST *l = list; l; l = l->next)
	{
	  char const*name = l->word->word;
	  opt_def_t const *d = find_option (name);
	  if (! d)
	    {
	      shopt_error (name);
	      rval = EXECUTION_FAILURE; /* TODO: maybe EX_BADUSAGE ? */
	      continue;
	    }
	  op_result_t r = set_opt_value (d, oc, value_s);
	  if (! GoodResult (r))
	    rval = EXECUTION_FAILURE;
	}

      #if 0 /* not needed - this is handled by set_opt_value */
      /* Don't set $BASHOPTS here if it hasn't already been initialized */
      if (find_variable ("BASHOPTS"))
	set_bashopts ();
      #endif
    }
  return sh_chkwrite (rval);
}

/* Reset the options managed by `shopt' to the values they would have at
   shell startup.  Variables from xo_options. */
void
reset_shopt_options (void)
{


  glob_asciirange = GLOBASCII_DEFAULT;
  patsub_replacement = PATSUB_REPLACE_DEFAULT;

#if defined (EXTENDED_GLOB)
  extended_glob = EXTGLOB_DEFAULT;
  extglob_flag = EXTGLOB_DEFAULT;
#endif
  glob_always_skip_dot_and_dotdot = 1;		/* new default as of bash-5.2 */

#if defined (HISTORY)
  force_append_history = 0;
  literal_history = 0;
#endif

#if defined (SYSLOG_HISTORY) && ! defined (SYSLOG_SHOPT)
  /* Have syslog history without the shopt to turn it off... */
  syslog_history = 1;
#endif /* !SYSLOG_SHOPT */

#if defined (READLINE)
  force_fignore = 1;
  hist_verify = history_reediting = 0;
  perform_hostname_completion = 1;
#  if DIRCOMPLETE_EXPAND_DEFAULT
  dircomplete_expand = 1;
#  else
  dircomplete_expand = 0;
#endif
  dircomplete_spelling = 0;
#endif

#if defined (PROGRAMMABLE_COMPLETION)
  prog_completion_enabled = 1;
#  if defined (ALIAS)
  progcomp_alias = 0;
#  endif
#endif
}

static void
shopt_error (char const*s)
{
  builtin_error (_("%s: invalid shell option name"), s);
}

#if defined (DEBUGGER)
static op_result_t
shopt_set_debug_mode (opt_def_t const *d, accessor_t why, int mode)
{
  d->store[0] = mode;
  error_trace_mode = function_trace_mode = debugging_mode;
  set_shellopts ();
  if (debugging_mode)
    init_bash_argv ();
  return Result (OK);
}
#endif

static op_result_t
shopt_set_expaliases (opt_def_t const *d, accessor_t why, int mode)
{
  d->store[0] = mode;
  expand_aliases = expaliases_flag;
  return Result (OK);
}

#if defined (EXTENDED_GLOB)
static op_result_t
shopt_set_extglob (opt_def_t const *d, accessor_t why, int mode)
{
  d->store[0] = mode;
  extended_glob = extglob_flag;
  return Result (OK);
}
#endif

#if defined (READLINE)
static op_result_t
shopt_enable_hostname_completion (opt_def_t const *d, accessor_t why, int mode)
{
  d->store[0] = mode;
  enable_hostname_completion (mode);
  return Result (OK);
}
#endif

static op_result_t
set_compatibility_level (opt_def_t const *d, accessor_t why, int mode)
{
  if (mode)
    shell_compatibility_level = d->reference_value;
  else if (shell_compatibility_level == d->reference_value)
    shell_compatibility_level = DEFAULT_COMPAT_LEVEL;
  else
    return Result (Ignored);

  /* Make sure the current compatibility level is reflected in BASH_COMPAT */
  char *rhs = itos (shell_compatibility_level);
  bind_variable ("BASH_COMPAT", rhs, 0);
  free (rhs);

  return Result (OK);
}

static option_value_t
get_compatibility_level (opt_def_t const *d, accessor_t why)
{
  return shell_compatibility_level == d->reference_value;
}

/* Set and unset the various compatibility options from the value of
   shell_compatibility_level; used by sv_shcompat
   TODO - no longer required */
void
set_compatibility_opts (void)
{
}

#if defined (READLINE)
static op_result_t
shopt_set_complete_direxpand (opt_def_t const *d, accessor_t why, int mode)
{
  d->store[0] = mode;
  set_directory_hook ();
  return Result (OK);
}
#endif

#if defined (RESTRICTED_SHELL)
/* Don't allow the value of restricted_shell to be modified. */

static op_result_t
set_restricted_shell (opt_def_t const *d, accessor_t why, int mode)
{
  d->store[0] = mode;

  static int save_restricted = -1;

  if (save_restricted == -1)
    save_restricted = shell_is_restricted (shell_name);

  restricted_shell = save_restricted;
  return Result (OK);
}
#endif /* RESTRICTED_SHELL */

/* Not static so shell.c can call it to initialize shopt_login_shell */
int
set_login_shell (char *option_name, int mode)
{
  return (0);
}

char **
get_shopt_options (void)
{
  size_t n = count_options_class (Accessor (shopt));
  char **ret = strvec_create (n + 1);
  opt_def_t const *d;
  size_t i = 0;
  for_each_option_class (d, Accessor (shopt))
    ret[i++] = savestring (d->name);
  ret[i] = NULL;
  return ret;
}

/*
 * External interface for other parts of the shell.  NAME is a string option;
 * MODE is 0 if we want to unset an option; 1 if we want to set an option.
 */
int
shopt_setopt (char const *name, int mode)
{
  opt_def_t const *d = find_option (name);
  if (! d)
    {
      shopt_error (name);
      return EXECUTION_FAILURE; /* TODO: maybe EX_BADUSAGE ? */
    }

  int rval = EXECUTION_SUCCESS;

  op_result_t r = set_opt_value (d, Accessor (shopt), mode);
  if (! GoodResult (r))
    rval = EXECUTION_FAILURE;

  /* Don't set $BASHOPTS here if it hasn't already been initialized */
  if (find_variable ("BASHOPTS"))
    set_bashopts ();
  return rval;
}

void
set_bashopts (void)
{
  size_t count = count_options ();
  char *tflag = xmalloc (count + 1);

  size_t vsize = 0;
  {
    size_t i = 0;
    opt_def_t const *d;
    for_each_option_class (d, Accessor (shopt))
      {
	int val = get_opt_value (d, Accessor (env_bashopts));
	tflag[i++] = val;
	if (val)
	  vsize += strlen (d->name) + 1;
      }
  }

  char const *value;

  {
    char *vend = xmalloc (vsize + 1);
    value = vend;
    size_t i = 0;
    opt_def_t const *d;
    for_each_option_class (d, Accessor (shopt))
      if (tflag[i++])
	{
	  vend = stpcpy (vend, d->name);
	  *vend++ = ':';
	}
    if (vend > value)
      vend--;			/* cut off trailing colon */
    *vend = '\0';
  }

  xfree (tflag);

  /* ASS_FORCE so we don't have to temporarily turn off readonly;
   * ASS_NOMARK so we don't tickle `set -a`. */
  SHELL_VAR *var = bind_variable ("BASHOPTS", value, ASS_FORCE | ASS_NOMARK);
  free (value);

  /* Turn the read-only attribute back on. */
  VSETATTR (var, att_readonly);
}

static void
parse_bashopts (char const*value)
{
  char const*vname;
  int vptr;

  vptr = 0;
  while (vname = extract_colon_unit (value, &vptr))
    {
      opt_def_t const *d = find_option (vname);
      if (d)
	set_opt_value(d, Accessor (env_bashopts), true);
      free (vname);
    }
}

void
initialize_bashopts (_Bool no_bashopts)
{
  if (!no_bashopts)
    {
      SHELL_VAR *var = find_variable ("BASHOPTS");
      /* set up any shell options we may have inherited. */
      if (var && imported_p (var) && !(array_p (var) || assoc_p (var)))
	{
	  char *temp = savestring (value_cell (var));
	  if (temp)
	    {
	      parse_bashopts (temp);
	      free (temp);
	    }
	}
    }

  /* Set up the $BASHOPTS variable. */
  set_bashopts ();
}

static op_result_t
set_ignoreeof (opt_def_t const *d, accessor_t why, int new_value)
{
  unbind_variable_noref ("ignoreeof");
  if (new_value)
    bind_variable ("IGNOREEOF", "10", 0);
  else
    unbind_variable_noref ("IGNOREEOF");
  sv_ignoreeof ("IGNOREEOF");
  return Result (OK);
}

static op_result_t
set_posix_mode (opt_def_t const *d, accessor_t why, int new_value)
{
  /* short-circuit on no-op */
  if (new_value != posixly_correct)
    {
      posixly_correct = new_value;
      if (posixly_correct)
	bind_variable ("POSIXLY_CORRECT", "y", 0);
      else
	unbind_variable_noref ("POSIXLY_CORRECT");
      sv_strict_posix ("POSIXLY_CORRECT");
    }
  return Result (OK);
}

#if defined (READLINE)
/* Magic.  This code `knows' how readline handles rl_editing_mode. */
static op_result_t
set_edit_mode (opt_def_t const *d, accessor_t why, option_value_t turn_on)
{
  if (turn_on)
    {
      rl_variable_bind ("editing-mode", d->name);
      if (interactive && !command_execution_string)
	with_input_from_stdin ();
    }
  else if (rl_editing_mode == d->reference_value)
    {
      if (interactive && !command_execution_string)
	with_input_from_stream (stdin, "stdin");
    }
  else
    return Result (Ignored);	/* Don't flip no_line_editing */
  no_line_editing = ! turn_on;
  return Result (OK);
}

static option_value_t
get_edit_mode (opt_def_t const *d, accessor_t why)
{
  return !no_line_editing && rl_editing_mode == d->reference_value;
}
#endif /* READLINE */

#if defined (HISTORY)
static op_result_t
set_history_flag (opt_def_t const *d, accessor_t why, int new_value)
{
  enable_history_list = new_value;
  if (enable_history_list)
    {
      bash_history_enable ();
      if (history_lines_this_session == 0)
	load_history ();
    }
  else
    bash_history_disable ();
  return Result (OK);
}
#endif

void
list_shopts (int reusable)
{
  display_style_t ds = reusable ? DisplayStyle (shopt) : DisplayStyle (on_off);
  opt_def_t const *d;
  for_each_option_class (d, Accessor (shopt))
    show_one_option (d, Accessor (shopt), ds);
}

void
register_shopt_opts (void)
{
  for (size_t i = 0 ; i < (sizeof (xo_options) / sizeof (xo_options[0])) ; ++i)
    register_option (&xo_options[i]);
}
