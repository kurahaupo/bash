This file is set.def, from which is created set.c.
It implements the "set" and "unset" builtins in Bash.

Copyright (C) 1987-2024 Free Software Foundation, Inc.

This file is part of GNU Bash, the Bourne Again SHell.

Bash is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Bash is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Bash.  If not, see <http://www.gnu.org/licenses/>.

$PRODUCES set.c

#include <config.h>

#if defined (HAVE_UNISTD_H)
#  ifdef _MINIX
#    include <sys/types.h>
#  endif
#  include <unistd.h>
#endif

#include <stdio.h>

#include "../bashansi.h"
#include "../bashintl.h"

#include "../shell.h"
#include "../parser.h"
#include "../flags.h"
#include "common.h"
#include "bashgetopt.h"

#if defined (READLINE)
#  include "../input.h"
#  include "../bashline.h"
#  include <readline/readline.h>
#endif

#if defined (HISTORY)
#  include "../bashhist.h"
#endif

#include "../options.h"

$BUILTIN set
$FUNCTION set_builtin
$SHORT_DOC set [-abefhkmnptuvxBCEHPT] [-o OPTNAME]... [--] [-] [PARAM ...]
If no options or arguments are given, display all shell variables; otherwise
display or change shell attributes and options, and/or set the positional
parameters.

Shell attributes and options have 'long' names, adjustable by using
"set -o OPTNAME" and "set +o OPTNAME", or equivalently by using
"shopt -s OPTNAME" and "shopt -u OPTNAME".

In addition, shell attributes have single-letter names, which are the same as
the options that Bash accepts when invoked, except for "-i", "-l", and "-r"
which can only be set at invocation.

Options:

  -a		same as "shopt -s allexport"
#if defined BRACE_EXPANSION
  -B		same as "shopt -s braceexpand" (non-POSIX)
#endif
#if defined JOB_CONTROL
  -b		same as "shopt -s notify"
#endif
  -C		same as "shopt -s noclobber"
  -e		same as "shopt -s errexit"
  -E		same as "shopt -s errtrace"    (non-POSIX)
  -f		same as "shopt -s noglob"
  -h		same as "shopt -s hashall"
#if defined BANG_HISTORY
  -H		same as "shopt -s histexpand"  (non-POSIX)
#endif
  -k		same as "shopt -s keyword"     (non-POSIX)
#if defined JOB_CONTROL
  -m		same as "shopt -s monitor"
#endif
  -n		same as "shopt -s noexec"
  -P		same as "shopt -s physical"    (non-POSIX)
  -p		same as "shopt -s privileged"  (non-POSIX)
  -T		same as "shopt -s functrace"   (non-POSIX)
  -t		same as "shopt -s onecmd"      (non-POSIX)
  -u		same as "shopt -s nounset"
  -v		same as "shopt -s verbose"
  -x		same as "shopt -s xtrace"

	(The same option letters with "+" instead of "-" correspond to using
	"shopt -u" rather than "shopt -s", to turn them off.)

  -o OPTNAME	same as "shopt -s OPTNAME"
  +o OPTNAME	same as "shopt -u OPTNAME"

  --  Clear the positional parameters, and stop processing options.
  -   Turn off the "-x" and "-v" options, and stop processing options.

Option processing also ceases when an option not starting with "+" or "-" is
encountered.

Once option processing has finished, if there are any remaining arguments, they
are assigned to the positional parameters; if there are no remaining arguments,
the positional parameters are left unchanged.

If -o is given with no OPTNAME, display the current shell option settings.
If +o is given with no OPTNAME, display a series of set commands to recreate
the current option settings.

Using + rather than - causes these flags to be turned off.  The flags can also
be used upon invocation of the shell.  The current set of flags may be found in
"$-".  The remaining PARAMs are assigned to the positional parameters.

Exit Status:
Returns success unless an invalid option is given.

Type "set --list-options" to see a brief list of options.
Type "set --option-help [OPTNAME ...]" to see short help for each option.
Type "set --option-usage [OPTNAME ...]" to see detailed help for each option.
$END

typedef int setopt_set_func_t (int, char const*);
typedef int setopt_get_func_t (char const*);

static void print_minus_o_option (char *, int, int);
static void print_all_shell_variables (void);

static opt_set_func_t set_ignoreeof;
static opt_set_func_t set_posix_mode;

#if defined (READLINE)
static opt_set_func_t set_edit_mode;
static opt_get_func_t get_edit_mode;
#endif

#if defined (HISTORY)
static opt_set_func_t set_history_flag;
#endif

static const char on[] = "on";
static const char off[] = "off";

static int previous_option_value;

/*
 * Keep aach option's terms in this order:
 *  Name, Letter
 *  Store (pointer)
 *  Init (pointer), Skip-reset
 *  Getter & Setter functions, Reference value
 *  Read-only, Forbid-change, Ignore-change
 *  (everything else in alphabetical order)
 *  Help
 */

static opt_def_t const xo_options[] = {
  { "ignoreeof",
    .store = &ignoreeof,
    .set_func = set_ignoreeof,
    .adjust_shellopts = true,
    .hide_shopt = true,
    .help = N_(
      "Do not immediately exit upon reading EOF"),
  },
  { "interactive-comments",
    .store = &interactive_comments,
    .adjust_bashopts = true,
    .adjust_shellopts = true,
    .hide_shopt = true,
    .help = N_(
      "Allow comments to appear in interactive commands"),
  },
  { "pipefail",
    .store = &pipefail_opt,
    .OPTRESET_REINIT_false,
    .adjust_shellopts = true,
    .hide_shopt = true,
    .help = N_(
      "Make the exit status of a pipeline be the last non-zero exit status of any of\n"
      "its components, or zero if the status of every component is zero.\n"
      "(Otherwise use the exit status of its right-most component.)"),
  },
  { "posix",
    .store = &posixly_correct,
    .set_func = set_posix_mode,
    .adjust_shellopts = true,
    .hide_shopt = true,
    .help = N_(
      "Disable most behaviours that deviate from what is permitted or required by\n"
      "the POSIX (IEEE-1003.1-2024) standard.")
  },
#if defined (READLINE)
  { "emacs",
    .hide_shopt = true,
    .get_func = get_edit_mode,
    .set_func = set_edit_mode,
    .reference_value = EMACS_EDITING_MODE,
    .adjust_shellopts = true,
    .help = N_(
      "Use an emacs-style line editing interface"),
  },
  { "vi",
    .get_func = get_edit_mode,
    .set_func = set_edit_mode,
    .reference_value = VI_EDITING_MODE,
    .adjust_shellopts = true,
    .hide_shopt = true,
    .help = N_(
      "Use a vi-style line editing interface"),
  },
#endif
#if defined (HISTORY)
  { "history",
    .store = &enable_history_list,
    .set_func = set_history_flag,
    .adjust_shellopts = true,
    .hide_shopt = true,
    .help = N_(
      "Enable command history"),
  },
  { "nolog",
    .store = &dont_save_function_defs,
    .adjust_shellopts = true,
    .hide_shopt = true,
    .help = N_(
      "(currently accepted but ignored)"),
  },
#endif
  //0
};

int
minus_o_option_value (char const *name)
{

  opt_def_t const *d = find_option (name);
  if (d)
    return get_opt_value (d, Accessor (set_o));
  else
    return FLAG_ERROR;
}

#define MINUS_O_FORMAT "%-15s\t%s\n"

static void
print_minus_o_option (char *name, int value, int pflag)
{
  if (pflag == 0)
    printf (MINUS_O_FORMAT, name, value ? on : off);
  else
    printf ("set %co %s\n", value ? '-' : '+', name);
}

void
list_minus_o_opts (int mode, int reusable)
{
  list_all_options (Accessor (set_o),
		    mode < 0 ? 0U : 1 << !mode,
		    reusable ? DisplayStyle (set_o)
			     : DisplayStyle (on_off));
}

char const*const*
get_minus_o_opts (void)
{
  size_t num_set_o_options = count_options_class (Accessor (set_o));
  char const**result = (char const**)strvec_create (num_set_o_options + 1);

  size_t i = 0;
  opt_def_t const *d;
  for_each_option_class (d, Accessor (set_o))
    result[i++] = d->name;
  result[i++] = NULL;
  return xrealloc (result, i);
}

char *
get_current_options (void)
{
  /* Make the buffer big enough to hold the set -o options and the shopt
     options modified by posix mode. */
  size_t num_set_o_options = count_options_class (Accessor (set_o));
  size_t posixopts = num_posix_options ();	/* shopts modified by posix mode */
  char *bitmap = xmalloc (num_set_o_options + posixopts + 1);

  size_t i = 0;
  opt_def_t const *d;
  for_each_option_class(d, Accessor (set_o))
    if (d->store)
      bitmap[i++] = d->store[0];  /* bypass accessor functions */

  /* Add the shell options that are modified by posix mode to the end of the
     bitmap. They will be handled in set_current_options () */
  get_posix_options (bitmap+i);
  i += posixopts;
  bitmap[i++] = '\0';
  return xrealloc (bitmap, i);
}

void
set_current_options (const char *bitmap)
{
  if (bitmap == NULL)
    return;

  size_t i = 0;
  opt_def_t const *d;
  for_each_option_class(d, Accessor (set_o))
    if (d->store)
      d->store[0] = bitmap[i++];  /* bypass accessor functions */

  /* Now reset the variables changed by posix mode */
  set_posix_options (bitmap+i);
}

static op_result_t
set_ignoreeof (opt_def_t const *d, accessor_t why, int new_value)
{
  unbind_variable_noref ("ignoreeof");
  if (new_value)
    bind_variable ("IGNOREEOF", "10", 0);
  else
    unbind_variable_noref ("IGNOREEOF");
  sv_ignoreeof ("IGNOREEOF");
  return Result (OK);
}

static op_result_t
set_posix_mode (opt_def_t const *d, accessor_t why, int new_value)
{
  /* short-circuit on no-op */
  if (new_value != posixly_correct)
    {
      posixly_correct = new_value;
      if (posixly_correct)
	bind_variable ("POSIXLY_CORRECT", "y", 0);
      else
	unbind_variable_noref ("POSIXLY_CORRECT");
      sv_strict_posix ("POSIXLY_CORRECT");
    }
  return Result (OK);
}

#if defined (READLINE)
/* Magic.  This code `knows' how readline handles rl_editing_mode. */
static op_result_t
set_edit_mode (opt_def_t const *d, accessor_t why, option_value_t turn_on)
{
  if (turn_on)
    {
      rl_variable_bind ("editing-mode", d->name);
      if (interactive && !command_execution_string)
	with_input_from_stdin ();
    }
  else if (rl_editing_mode == d->reference_value)
    {
      if (interactive && !command_execution_string)
	with_input_from_stream (stdin, "stdin");
    }
  else
    return Result (Ignored);	/* Don't flip no_line_editing */
  no_line_editing = ! turn_on;
  return Result (OK);
}

static option_value_t
get_edit_mode (opt_def_t const *d, accessor_t why)
{
  return !no_line_editing && rl_editing_mode == d->reference_value;
}
#endif /* READLINE */

#if defined (HISTORY)
static op_result_t
set_history_flag (opt_def_t const *d, accessor_t why, int new_value)
{
  enable_history_list = new_value;
  if (enable_history_list)
    {
      bash_history_enable ();
      if (history_lines_this_session == 0)
	load_history ();
    }
  else
    bash_history_disable ();
  return Result (OK);
}
#endif

int
set_minus_o_option (char on_or_off, char const*option_name)
{
  opt_def_t const *d = find_option (option_name);
  if (!d)
    {
      sh_invalidoptname (option_name);
      return EX_USAGE;
    }

  op_result_t r = set_opt_value (d, Accessor (set_o), flag_to_bool (on_or_off));

  if (GoodResult (r))
    return EXECUTION_SUCCESS;

  sh_invalidoptname (option_name);
  return EXECUTION_FAILURE;
}

static void
print_all_shell_variables (void)
{
  SHELL_VAR **vars = all_shell_variables ();
  if (vars)
    {
      print_var_list (vars);
      free (vars);
    }

  /* POSIX.2 does not allow function names and definitions to be output when
     `set' is invoked without options (PASC Interp #202). */
  if (posixly_correct == 0)
    {
      vars = all_shell_functions ();
      if (vars)
	{
	  print_func_list (vars);
	  free (vars);
	}
    }
}

void
set_shellopts (void)
{
  size_t count = count_options ();
  char *tflag = xmalloc (count + 1);

  size_t vsize = 0;
  {
    size_t i = 0;
    opt_def_t const *d;
    for_each_option_class (d, Accessor (set_o))
      {
	int val = get_opt_value (d, Accessor (short));
	tflag[i++] = val;
	if (val)
	  vsize += strlen (d->name) + 1;
      }
  }

  char const *value;

  {
    char *vend = xmalloc (vsize + 1);
    value = vend;
    size_t i = 0;
    opt_def_t const *d;
    for_each_option_class (d, Accessor (set_o))
      if (tflag[i++])
	{
	  vend = stpcpy (vend, d->name);
	  *vend++ = ':';
	}
    if (vend > value)
      vend--;			/* cut off trailing colon */
    *vend = '\0';
  }

  xfree (tflag);

  /* ASS_FORCE so we don't have to temporarily turn off readonly;
   * ASS_NOMARK so we don't tickle `set -a`. */
  SHELL_VAR *var = bind_variable ("SHELLOPTS", value, ASS_FORCE | ASS_NOMARK);
  free (value);

  /* Turn the read-only attribute back on. */
  VSETATTR (var, att_readonly);
}

void
parse_shellopts (char *value)
{
  char const *vname;
  int vptr;

  vptr = 0;
  while (vname = extract_colon_unit (value, &vptr))
    {
      set_minus_o_option (FLAG_ON, vname);
      free (vname);
    }
}

void
initialize_shell_options (_Bool no_shellopts)
{
  if (!no_shellopts)
    {
      SHELL_VAR *var = find_variable ("SHELLOPTS");
      /* set up any shell options we may have inherited. */
      if (var && imported_p (var) && !(array_p (var) || assoc_p (var)))
	{
	  char *temp = savestring (value_cell (var));
	  if (temp)
	    {
	      parse_shellopts (temp);
	      free (temp);
	    }
	}
    }

  /* Set up the $SHELLOPTS variable. */
  set_shellopts ();
}

/* Reset the values of the -o options that are not also shell flags.  This is
   called from execute_cmd.c:initialize_subshell () when setting up a subshell
   to run an executable shell script without a leading `#!'. */
void
reset_shell_options (void)
{
  ignoreeof = 0;

  interactive_comments = 1;

#if defined (STRICT_POSIX)
  posixly_correct = 1;
#else
  posixly_correct = 0;
#endif
#if defined (HISTORY)
  dont_save_function_defs = 0;
  remember_on_history = enable_history_list = 1;	/* XXX */
#endif
}

static char *optflags = NULL;

static void
invalidate_optflags (void)
{
  if (!optflags)
    return;
  xfree (optflags);
  optflags = NULL;
}

static void
init_optflags (void)
{
  if (optflags)
    return;
  char const * option_names = get_short_opt_names ();
  optflags = xmalloc (strlen (option_names) + 4);
  sprintf (optflags, "+%so;", option_names);
}

static inline _Bool
match (char const *arg, char const *pattern, size_t min)
{
  size_t plen = strlen (pattern);
  if (min == 0 || min > plen)
    min = plen;
  size_t alen = strlen (arg);
  return min <= alen && alen <= plen
      && 0 == memcmp (arg, pattern, alen);
}

/* Set some flags from the word values in the input list.  If LIST is empty,
   then print out the values of the variables instead.  If LIST contains
   non-flags, then set $1 - $9 to the successive words of LIST. */
int
set_builtin (WORD_LIST *list)
{
  int on_or_off, flag_name, force_assignment, opts_changed, rv, r;
  register char *arg;
  char s[3];

  if (list == 0)
    {
      print_all_shell_variables ();
      return (sh_chkwrite (EXECUTION_SUCCESS));
    }

  for (;list && list->word && (arg = list->word->word) && arg[0] == '-' && arg[1] == '-' && arg[2]; list = list->next)
    {
      int help_level = 0;
      if (match (arg, "--list-options", 3)) help_level = 1; else
      if (match (arg, "--options", 3) || match (arg, "--option-help", 10) || match (arg, "--help-options", 8)) help_level = 2; else
      if (match (arg, "--usage",   3) || match (arg, "--option-usage", 10)) help_level = 3; else
	{
	  builtin_usage ();
	  return (EX_USAGE);
	}
      list_all_options (Accessor (set_o),
			0U,
			DisplayStyle (help1-1+help_level));
      rv = sh_chkwrite (rv);
      return EXECUTION_SUCCESS;
    }

  /* Check validity of flag arguments. */
  rv = EXECUTION_SUCCESS;
  init_optflags ();
  reset_internal_getopt ();
  while ((flag_name = internal_getopt (list, optflags)) != -1)
    {
      switch (flag_name)
	{
	  case 'i':	/* don't allow set -i */
	    s[0] = list_opttype;
	    s[1] = 'i';
	    s[2] = '\0';
	    sh_invalidopt (s);
	    builtin_usage ();
	    return (EX_USAGE);
	  CASE_HELPOPT;
	  case '?':
	    builtin_usage ();
	    return (list_optopt == '?' ? EXECUTION_SUCCESS : EX_USAGE);
	  default:
	    break;
	}
    }

  /* Do the set command.  While the list consists of words starting with
     '-' or '+' treat them as flags, otherwise, start assigning them to
     $1 ... $n. */
  for (force_assignment = opts_changed = 0; list; )
    {
      arg = list->word->word;

      /* If the argument is `--' or `-' then signal the end of the list
	 and remember the remaining arguments. */
      if (arg[0] == '-' && (!arg[1] || (arg[1] == '-' && !arg[2])))
	{
	  list = list->next;

	  /* `set --' unsets the positional parameters. */
	  if (arg[1] == '-')
	    force_assignment = 1;

	  /* Until told differently, the old shell behaviour of
	     `set - [arg ...]' being equivalent to `set +xv [arg ...]'
	     stands.  Posix.2 says the behaviour is marked as obsolescent. */
	  else
	    {
	      change_flag ('x', '+');
	      change_flag ('v', '+');
	      opts_changed = 1;
	    }

	  break;
	}

      if ((on_or_off = *arg) && (on_or_off == '-' || on_or_off == '+'))
	{
	  while (flag_name = *++arg)
	    {
	      if (flag_name == '?')
		{
		  builtin_usage ();
		  return (EXECUTION_SUCCESS);
		}
	      else if (flag_name == 'o') /* -+o option-name */
		{
		  char *option_name;
		  WORD_LIST *opt;

		  opt = list->next;

		  if (opt == 0)
		    {
		      _Bool reusable = !flag_to_bool (on_or_off);
		      list_all_options (Accessor (set_o),
					0U,
					reusable ? DisplayStyle (set_o)
						 : DisplayStyle (on_off));
		      rv = sh_chkwrite (rv);
		      continue;
		    }

		  option_name = opt->word->word;

		  if (option_name == 0 || *option_name == '\0' ||
		      *option_name == '-' || *option_name == '+')
		    {
		      _Bool reusable = !flag_to_bool (on_or_off);
		      list_all_options (Accessor (set_o),
					0U,
					reusable ? DisplayStyle (set_o)
						 : DisplayStyle (on_off));
		      continue;
		    }
		  list = list->next; /* Skip over option name. */

		  opts_changed = 1;
		  if ((r = set_minus_o_option (on_or_off, option_name)) != EXECUTION_SUCCESS)
		    {
		      #if 0 /* not needed - this is handled by set_opt_value when .adjust_shellopts is true */
		      set_shellopts ();
		      #endif
		      return (r);
		    }
		}
	      else if (change_flag (flag_name, on_or_off) == FLAG_ERROR)
		{
		  s[0] = on_or_off;
		  s[1] = flag_name;
		  s[2] = '\0';
		  sh_invalidopt (s);
		  builtin_usage ();
		  #if 0 /* not needed - this is handled by set_opt_value when .adjust_shellopts is true */
		  set_shellopts ();
		  #endif
		  return (EXECUTION_FAILURE);
		}
	      opts_changed = 1;
	    }
	}
      else
	break;
      list = list->next;
    }

  /* Assigning $1 ... $n */
  if (list || force_assignment)
    remember_args (list, 1);
  #if 0 /* not needed - this is handled by set_opt_value when .adjust_shellopts is true */
  /* Set up new value of $SHELLOPTS */
  if (opts_changed)
    set_shellopts ();
  #endif
  return (rv);
}

$BUILTIN unset
$FUNCTION unset_builtin
$SHORT_DOC unset [-f] [-v] [-n] [name ...]
Unset values and attributes of shell variables and functions.

For each NAME, remove the corresponding variable or function.

Options:
  -f	treat each NAME as a shell function
  -v	treat each NAME as a shell variable
  -n	treat each NAME as a name reference and unset the variable itself
		rather than the variable it references

Without options, unset first tries to unset a variable, and if that fails,
tries to unset a function.

Some variables cannot be unset; also see `readonly'.

Exit Status:
Returns success unless an invalid option is given or a NAME is read-only.
$END

#define NEXT_VARIABLE()	any_failed++; list = list->next; continue;

#define RESTORE_NAME() \
do { \
  tname = name + strlen (name); \
  if (tname == t - 1)	/* probably a paranoid check */ \
    { \
      tname[0] = '['; \
      t[strlen (t)] = ']'; \
    } \
} while (0)

int
unset_builtin (WORD_LIST *list)
{
  int unset_function, unset_variable, unset_array, opt, nameref, any_failed;
  int global_unset_func, global_unset_var, vflags, base_vflags, valid_id;
  int posix_utility_error;
  char *name, *tname;

  unset_function = unset_variable = unset_array = nameref = 0;
  posix_utility_error = any_failed = 0;
  global_unset_func = global_unset_var = 0;

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "fnv")) != -1)
    {
      switch (opt)
	{
	case 'f':
	  global_unset_func = 1;
	  break;
	case 'v':
	  global_unset_var = 1;
	  break;
	case 'n':
	  nameref = 1;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }

  list = loptend;

  if (global_unset_func && global_unset_var)
    {
      builtin_error (_("cannot simultaneously unset a function and a variable"));
      return (EXECUTION_FAILURE);
    }
  else if (unset_function && nameref)
    nameref = 0;

#if defined (ARRAY_VARS)
  base_vflags = array_expand_once ? VA_NOEXPAND : 0;
#endif

  while (list)
    {
      SHELL_VAR *var;
      int tem;
#if defined (ARRAY_VARS)
      char *t;
#endif

      name = list->word->word;

      unset_function = global_unset_func;
      unset_variable = global_unset_var;

#if defined (ARRAY_VARS)
      vflags = builtin_arrayref_flags (list->word, base_vflags);
      unset_array = 0;
      /* XXX valid array reference second arg was 0 */
      /* XXX tokenize_array_reference modifies NAME if it succeeds */
      if (unset_function == 0 && nameref == 0 && tokenize_array_reference (name, vflags, &t))
	unset_array = 1;
#endif

      /* Get error checking out of the way first.  The low-level functions
	 just perform the unset, relying on the caller to verify. */
      valid_id = valid_identifier (name);

      /* Whether or not we are in posix mode, if neither -f nor -v appears,
	 skip over trying to unset variables with invalid names and just
	 treat them as potential shell function names. */
      if (global_unset_func == 0 && global_unset_var == 0 && valid_id == 0)
	{
#if defined (ARRAY_VARS)
	  if (unset_array)
	    RESTORE_NAME ();
#endif
	  unset_variable = unset_array = 0;
	  unset_function = 1;
	}

      /* Bash allows functions with names which are not valid identifiers
	 to be created when not in posix mode, so check only when in posix
	 mode when unsetting a function. */
      if (unset_function == 0 && valid_id == 0)
	{
	  sh_invalidid (name);
	  posix_utility_error++;
	  NEXT_VARIABLE ();
	}

      /* Search for functions here if -f supplied or if NAME cannot be a
	 variable name. */
      var = unset_function ? find_function (name)
			   : (nameref ? find_variable_last_nameref (name, 0) : find_variable (name));

      /* Some variables (but not functions yet) cannot be unset, period. */
      if (var && unset_function == 0 && non_unsettable_p (var))
	{
	  builtin_error (_("%s: cannot unset"), name);
	  posix_utility_error++;
	  NEXT_VARIABLE ();
	}

      /* if we have a nameref we want to use it */
      if (var && unset_function == 0 && nameref == 0 && STREQ (name, name_cell (var)) == 0)
	name = name_cell (var);

      /* Posix.2 says try variables first, then functions.  If we would
	 find a function after unsuccessfully searching for a variable,
	 note that we're acting on a function now as if -f were
	 supplied.  The readonly check below takes care of it. */
      if (var == 0 && nameref == 0 && unset_variable == 0 && unset_function == 0)
	{
#if defined (ARRAY_VARS)
	  /* We modified NAME in the call to tokenize_array_reference, so we
	     need to restore it here. We turned the original `[' and `]' into
	     NULL, to isolate the array name and subscript. This only happens
	     if tokenize_array_reference succeeds with a non-NULL subscript
	     pointer, and UNSET_ARRAY is set to 1 only in this case. */
	  if (unset_array)
	    {
	      RESTORE_NAME ();
	      unset_array = 0;
	    }
#endif
	  if (var = find_function (name))
	    unset_function = 1;
	}

      /* Posix.2 says that unsetting readonly variables is an error. */
      if (var && readonly_p (var))
	{
	  builtin_error (_("%s: cannot unset: readonly %s"),
			 var->name, unset_function ? "function" : "variable");
	  posix_utility_error++;
	  NEXT_VARIABLE ();
	}

      /* Unless the -f option is supplied, the name refers to a variable. */
#if defined (ARRAY_VARS)
      if (var && unset_array)
	{
	  if (shell_compatibility_level <= 51)
	    vflags |= VA_ALLOWALL;

	  /* Let unbind_array_element decide what to do with non-array vars */
	  tem = unbind_array_element (var, t, vflags);	/* XXX new third arg */
	  if (tem == -2 && array_p (var) == 0 && assoc_p (var) == 0)
	    {
	      builtin_error (_("%s: not an array variable"), var->name);
	      NEXT_VARIABLE ();
	    }
	  else if (tem < 0)
	    any_failed++;
	}
      else
#endif /* ARRAY_VARS */
      /* If we're trying to unset a nameref variable whose value isn't a set
	 variable, make sure we still try to unset the nameref's value */
      if (var == 0 && nameref == 0 && unset_function == 0)
	{
	  var = find_variable_last_nameref (name, 0);
	  if (var && nameref_p (var))
	    {
#if defined (ARRAY_VARS)
	      if (valid_array_reference (nameref_cell (var), 0))
		{
		  int len;

		  tname = savestring (nameref_cell (var));
		  tem = 0;
		  if (var = array_variable_part (tname, 0, &t, &len))
		    {
		      /* change to what unbind_array_element now expects */
		      if (t[len - 1] == ']')
			t[len - 1] = 0;
		      tem = unbind_array_element (var, t, vflags);	/* XXX new third arg */
		    }
		  free (tname);
		}
	      else
#endif
		tem = unbind_variable (nameref_cell (var));
	    }
	  else if (posixly_correct && var && tempvar_p (var))
	    tem = posix_unbind_tempvar (name);
	  else
	    tem = unbind_variable (name);
	}
      else if (posixly_correct && unset_function == 0 && nameref == 0 && var && tempvar_p (var))
	tem = posix_unbind_tempvar (name);
      else
	tem = unset_function ? unbind_func (name) : (nameref ? unbind_nameref (name) : unbind_variable (name));

      /* This is what Posix.2 says:  ``If neither -f nor -v
	 is specified, the name refers to a variable; if a variable by
	 that name does not exist, it is unspecified whether  a function
	 by that name, if any, shall be unset.'' The unspecified part is a
	 recent addition, so we continue to try to unset a shell function if
	 we don't find a variable named NAME. */
      if (tem == -1 && nameref == 0 && unset_function == 0 && unset_variable == 0)
	tem = unbind_func (name);

      name = list->word->word;		/* reset above for namerefs */

      /* SUSv3, POSIX.1-2001 say:  ``Unsetting a variable or function that
	 was not previously set shall not be considered an error.'' */

      if (unset_function == 0)
	stupidly_hack_special_variables (name);

      list = list->next;
    }

  return (any_failed ? (posix_utility_error ? EX_UTILERROR : EXECUTION_FAILURE) : EXECUTION_SUCCESS);
}

void
register_set_opts (void)
{
  for (size_t i = 0 ; i < (sizeof (xo_options) / sizeof (xo_options[0])) ; ++i)
    register_option (&xo_options[i]);
}
