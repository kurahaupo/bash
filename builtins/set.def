This file is set.def, from which is created set.c.
It implements the ‘set’, ‘shopt’, and ‘unset’ builtins in Bash.

Copyright (C) 1987-2024 Free Software Foundation, Inc.

This file is part of GNU Bash, the Bourne Again SHell.

Bash is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Bash is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Bash.  If not, see <http://www.gnu.org/licenses/>.

$PRODUCES set.c

#include <config.h>

#if defined (HAVE_UNISTD_H)
#  ifdef _MINIX
#    include <sys/types.h>
#  endif
#  include <unistd.h>
#endif

#include <stdio.h>

#include "version.h"

#include "../bashansi.h"
#include "../bashintl.h"

#include "../shell.h"
#include "../parser.h"
#include "../flags.h"
#include "common.h"
#include "bashgetopt.h"

#if defined (READLINE)
#  include "../input.h"
#  include "../bashline.h"
#  include <readline/readline.h>
#endif

#if defined (HISTORY)
#  include "../bashhist.h"
#endif

#if defined (JOB_CONTROL)
/* copied from jobs.h */
extern int set_job_control (int);
#endif

typedef int option_value_t;

#define OPTION_INVALID_VALUE ((option_value_t)-1)
#define OPTION_VALUE_UNSET   ((option_value_t)-2)

/* Rather than bald enums, use singleton structs to ensure we cannot
 * accidentally mix these up with ints */

/* Whence: when setting an option, whether it's allowed may depend on how it's
 * attempted to be changed. */
enum optset_whence_e {
  Whence_any = 0,	/* unlabelled zero default; computation of correct value is still pending */
  Whence_short,		/* using set -X (a short single-letter option) */
  Whence_set_o,		/* using set -o NAME */
  Whence_shopt,		/* using shopt -s NAME */
  Whence_argv,		/* parsed from argv when Bash starts up */
  Whence_environ,	/* read from the environment when Bash starts up */
  Whence_unwind,	/* automatically being restored during unwinding */
};

#ifdef FAST_ENUM
typedef enum optset_whence_e optset_whence_t;
#define Whence(X)	WhenceV (X)
#define WhenceC(E)	(E)
#else

/* Use a small struct to prevent it being conflated with an "int".
 * (Modern compilers generate identical code either way, but older compilers
 * may generate markedly worse code for structs.) */
typedef struct optset_whence_s {
  enum optset_whence_e whence;
} optset_whence_t;
#define Whence(X)	(struct optset_whence_s){ .whence = WhenceV (X) }
#define WhenceC(E)	(E).whence
#endif
#define WhenceCM(E)	(1U << WhenceC (E))
#define WhenceV(X)	Whence_##X
#define WhenceVM(X)	(1U << WhenceV (X))

enum optset_result_e {
  Result_OK,
  Result_Unchanged,	/* New value is same as old value */
  Result_Ignored,	/* Change request ignored, silently */
  Result_NotFound,	/* No setting with the supplied letter or name */
  Result_ReadOnly,	/* Change never possible */
  Result_Forbidden,	/* Not changed because new value is permitted */
  Result_BadValue,	/* Like ReadOnly but doesn't complain if the new value is the same as the old value */
};

#ifdef FAST_ENUM
typedef enum optset_result_e optset_result_t;
#define Result(X)	ResultV (X)
#define ResultC(R)	(R)
#else
/* Use a small struct to prevent it being conflated with an "int".
 * (Modern compilers generate identical code either way, but older compilers
 * may generate markedly worse code for structs.) */
typedef struct optset_result_s {
  enum optset_result_e result;
} optset_result_t;
#define Result(X)	(struct optset_result_s){ .result = ResultV (X) }
#define ResultC(R)	(R).result
#endif

#define ResultCM(R)	(1U << ResultC (R))
#define ResultV(X)	Result_##X
#define ResultVM(X)	(1U << ResultV (X))

#define GoodResult(R)	(ResultC (R) <= Result_Ignored)
#define BadResult(R)	(! GoodResult (R))

static const int result_to_ex_map[] = {
  [Result_OK]		= EXECUTION_SUCCESS,
  [Result_Unchanged]	= EXECUTION_SUCCESS,	/* New value is same as old value */
  [Result_Ignored]	= EXECUTION_SUCCESS,	/* Change request ignored, silently */
  [Result_NotFound]	= EX_BADUSAGE,		/* No setting with the supplied letter or name */
  [Result_ReadOnly]	= EX_BADUSAGE,		/* Change never possible */
  [Result_Forbidden]	= EX_BADASSIGN,		/* Not changed because new value is permitted */
  [Result_BadValue]	= EX_BADASSIGN,		/* Not changed because new value not valid */
};
#define res_to_ex(res) result_to_ex_map[ResultC (res)]

struct opt_def_s;  /* forward ref */

typedef optset_result_t opt_set_func_t (struct opt_def_s const *option_def,
                                        optset_whence_t set_vs_shopt,
                                        option_value_t new_value);
typedef option_value_t opt_get_func_t (struct opt_def_s const *option_def,
				       optset_whence_t set_vs_shopt);

typedef struct opt_def_s {
  char const *name;
  option_value_t *store;
  option_value_t const *init;
  opt_set_func_t *set_func;
  opt_get_func_t *get_func;
  int   reference_value;
  char  letter;
  _Bool hide_set_o:1,
	hide_shopt:1,
	adjust_bashopts:1,
	adjust_shellopts:1,
	readonly:1,		/* when attempting to set an option: error (Readonly) unconditionally */
	forbid_change:1,	/*				     error (Forbidden) if attempting to change its value */
	ignore_change:1,	/*				     succeed (Ignored) without actually changing the value */
	:0;
} opt_def_t;

static option_value_t
get_opt_value (opt_def_t const *d, optset_whence_t w)
{
  if (!d)
    return OPTION_INVALID_VALUE;
  if (d->get_func)
    return d->get_func(d, w);
  if (d->store)
    return d->store[0];
  return OPTION_INVALID_VALUE;
}

static optset_result_t
set_opt_value (opt_def_t const *d,
	       optset_whence_t w,
	       option_value_t new_value)
{
  if (!d)
    return Result (NotFound);

  if (d->set_func)
    {
      optset_result_t r = d->set_func(d, w, new_value);
      if (ResultC (r) == Result_OK)
	{
	  /* only for exactly Result_OK; "not changed" or "ignored" should not trigger this */
	  if (d->adjust_shellopts) set_shellopts ();
	  if (d->adjust_bashopts) set_bashopts ();
	}
      return r;
    }

  if (d->readonly)
    return Result (ReadOnly);
  if (d->forbid_change && WhenceC (w) != Whence_argv		/* set up from command line, but don't change thereafter */
		       && WhenceC (w) != Whence_environ)	/* read from initial environment, but don't change thereafter */
    {
      option_value_t old_value = get_opt_value (d, w);
      if (new_value == old_value)
	return Result (Unchanged);
      else if (d->ignore_change)
	return Result (Ignored);
      else
	return Result (Forbidden);
    }
  if (d->ignore_change)
    return Result (Ignored);

  if (d->store)
    d->store[0] = new_value;
  if (d->adjust_shellopts) set_shellopts ();
  if (d->adjust_bashopts) set_bashopts ();
  return Result (OK);
}

static const char on[] = "on";
static const char off[] = "off";
static const char no_long_name[] = "-";

static _Bool
hide_when_shopt (opt_def_t const *d)
{
  return d->hide_shopt;
}

static _Bool
hide_when_short (opt_def_t const *d)
{
  return d->letter == 0;
}

static _Bool
hide_when_set_o (opt_def_t const *d)
{
  return d->hide_set_o;
}

static _Bool (*hide_when_map[])(opt_def_t const *d) = {
  [Whence_short] = hide_when_short,
  [Whence_set_o] = hide_when_set_o,
  [Whence_shopt] = hide_when_shopt,
};

static void
show_option_default (opt_def_t const *d, optset_whence_t whence_selection)
{
  printf ("%-15s\t%s\n", d->name, get_opt_value (d, whence_selection) ? on : off);
}

static void
show_option_shopt (opt_def_t const *d, optset_whence_t whence_selection)
{
  printf ("shopt -%c %s\n", get_opt_value (d, whence_selection) ? 's' : 'u', d->name);
}

static void
show_option_short (opt_def_t const *d, optset_whence_t whence_selection)
{
  printf ("set %c%c\n", bool_to_flag (get_opt_value (d, whence_selection)), d->letter);
}

static void
show_option_set_o (opt_def_t const *d, optset_whence_t whence_selection)
{
  printf ("set %co %s\n", bool_to_flag (get_opt_value (d, whence_selection)), d->name);
}

static void (*show_map[])(opt_def_t const *d, optset_whence_t whence_selection) = {
  [Whence_any]   = show_option_default,
  [Whence_short] = show_option_short,
  [Whence_set_o] = show_option_set_o,
  [Whence_shopt] = show_option_shopt,
};

/******************************************************************************/

int expaliases_flag = 0;

extern int allow_null_glob_expansion;	// from pathexp.h /* nullglob */

#if defined (ARRAY_VARS)
extern int array_expand_once;	// from arrayfunc.h
#endif

//extern int autocd;	// in shell.h
extern int bash_source_fullpath;	// from variables.c
extern int cdable_vars;	// from cd.def
extern int cdspelling;	// from cd.def
extern int check_hashed_filenames;	// from findcmd.h
extern int check_window_size;	// from jobs.c & nojobs.c

#if defined (DEBUGGER)
extern int debugging_mode;	// in shell.h
#endif

#if defined (READLINE)
#  if DIRCOMPLETE_EXPAND_DEFAULT
#    define DIRCOMPLETE_EXPAND_INIT one
#  else
#    define DIRCOMPLETE_EXPAND_INIT zero
#  endif
#endif

extern int expand_aliases;	// from parse.y

#if defined (EXTENDED_GLOB)
extern int extended_glob;	// from pathexp.h
#endif

extern int extended_quote;	// from parse.y
extern int fail_glob_expansion;	// from pathexp.h
extern int glob_always_skip_dot_and_dotdot;	// from glob.c
extern int glob_asciirange;	// from smatch.c
extern int glob_dot_filenames;	// from pathexp.h
extern int glob_ignore_case;	// from glob.h
extern int glob_star;	// from pathexp.h
extern int gnu_error_format;	// from error.c
extern int inherit_errexit;	// from subst.c
extern int lastpipe_opt;	// from execute_cmd.c
extern int localvar_inherit;	// from variables.h
extern int localvar_unset;	// from variables.c
extern int mail_warning;	// from mailcheck.c
extern int match_ignore_case;	// from pathexp.h
extern int no_exit_on_failed_exec;	// from exec.def  /* execfail */
extern int patsub_replacement;	// from subst.c

#if defined (STRICT_POSIX)
#  define POSIXLY_CORRECT_INIT  0
#else
#  define POSIXLY_CORRECT_INIT -1
#endif

extern int print_shift_error;	// from general.c

#if defined (PROGRAMMABLE_COMPLETION)
extern int prog_completion_enabled;	// from pcomplete.h
extern int progcomp_alias;	// from pcomplete.h
#endif

extern int promptvars;	// parse.y
extern int singlequote_translations;	// from parse.y
extern int source_uses_path;	// from source.def

#if defined (SYSLOG_HISTORY)
extern int syslog_history;
#  if defined (SYSLOG_SHOPT)
#    define SYSLOG_HISTORY_INIT SYSLOG_SHOPT
#  else
#    define SYSLOG_HISTORY_INIT 1
#  endif /* SYSLOG_SHOPT */
#endif

extern int varassign_redir_autoclose;	// from redir.c
extern int xpg_echo;	// from echo.def

#if defined (DEFAULT_ECHO_TO_XPG) || defined (STRICT_POSIX)
#  define XPG_ECHO_INIT one
#else
#  define XPG_ECHO_INIT zero
#endif /* DEFAULT_ECHO_TO_XPG */

#if defined (READLINE)

//extern int complete_fullquote;	// in bashline.h
//extern int dircomplete_expand;	// in bashline.h
//extern int dircomplete_spelling;	// in bashline.h
//extern int enable_hostname_completion (int);	// in bashline.h
//extern int force_fignore;	// in bashline.h
//extern int no_empty_command_completion;	// in bashline.h
//extern int perform_hostname_completion;	// in bashline.h

# if defined (HISTORY)
//extern int hist_verify;	// in bashhist.h conditional on READLINE
//extern int history_reediting;	// in bashhist.h conditional on READLINE
# endif
#endif


static int shopt_login_shell;

/******************************************************************************/

static opt_get_func_t get_compatibility_level;
static opt_set_func_t set_compatibility_level;

#if defined (READLINE)
static opt_set_func_t shopt_set_complete_direxpand;
#endif

static opt_set_func_t shopt_set_debug_mode;

#if defined (READLINE)
static opt_set_func_t set_edit_mode;
static opt_get_func_t get_edit_mode;
#endif

static opt_set_func_t shopt_set_expaliases;

static opt_set_func_t set_errexit_flag;
#if defined (EXTENDED_GLOB)
int extglob_flag = EXTGLOB_DEFAULT;
static opt_set_func_t shopt_set_extglob;
#endif

#if defined (BANG_HISTORY)
static opt_set_func_t set_histexp_flag;
#endif

#if defined (READLINE)
static opt_set_func_t shopt_enable_hostname_completion;
#endif

#if defined (BANG_HISTORY)
static opt_set_func_t set_histexp_flag;
#endif

#if defined (HISTORY)
static opt_set_func_t bash_set_history;
#endif

static opt_set_func_t set_ignoreeof;

#if defined (JOB_CONTROL)
static opt_set_func_t set_monitor_flag;
#endif

static opt_set_func_t set_noexec_flag;
static opt_set_func_t set_posix_mode;
static opt_set_func_t set_privileged_flag;

#if defined (JOB_CONTROL)
static opt_set_func_t set_monitor_flag;
#endif

static opt_set_func_t set_privileged_flag;

#if defined (RESTRICTED_SHELL)
static opt_set_func_t set_restricted_flag;
static opt_set_func_t set_restricted_shell;
#endif

static opt_set_func_t set_verbose_flag;

/******************************************************************************/

/* If you add a new variable name here, make sure to include an appropriate
 * initializer here (if using the referenced variable), or set the default
 * value appropriately in reset_shell_options (if using a different variable).
 */

/******************************************************************************/

static option_value_t const zero[1] = {0};
static option_value_t const one[1] = {1};

static const opt_def_t opt_defs[] = {
  { "allexport",		&mark_modified_vars,	.letter = 'a',	.hide_shopt = 1 },
#if defined (ARRAY_VARS)
  { "array_expand_once",	&array_expand_once,	.hide_set_o = 1 },
  { "assoc_expand_once",	&array_expand_once,	.hide_set_o = 1,	.hide_shopt = 1 },
#endif
  { "autocd",			&autocd,	.hide_set_o = 1,	.init = zero },
#if defined (ARRAY_VARS)
  { "bash_source_fullpath",	&bash_source_fullpath,	.hide_set_o = 1 },
#endif
#if defined (BRACE_EXPANSION)
  { "braceexpand",		&brace_expansion,	.letter = 'B',	.hide_shopt = 1 },
#endif
  { "cdable_vars",		&cdable_vars,	.hide_set_o = 1,	.init = zero },
  { "cdspell",			&cdspelling,	.hide_set_o = 1,	.init = zero },
  { "checkhash",		&check_hashed_filenames,	.hide_set_o = 1,	.init = &(int){CHECKHASH_DEFAULT} },
#if defined (JOB_CONTROL)
  { "checkjobs",		&check_jobs_at_exit,	.hide_set_o = 1,	.init = zero },
#endif
  { "checkwinsize",		&check_window_size,	.hide_set_o = 1,	.init = &(int){CHECKWINSIZE_DEFAULT} },
#if defined (HISTORY)
  { "cmdhist",			&command_oriented_history,	.hide_set_o = 1,	.init = one },
#endif
  { "compat31",			&shell_compatibility_level,	.get_func = get_compatibility_level,	.set_func = set_compatibility_level,	.reference_value = 31,	.hide_set_o = 1 },
  { "compat32",			&shell_compatibility_level,	.get_func = get_compatibility_level,	.set_func = set_compatibility_level,	.reference_value = 32,	.hide_set_o = 1 },
  { "compat40",			&shell_compatibility_level,	.get_func = get_compatibility_level,	.set_func = set_compatibility_level,	.reference_value = 40,	.hide_set_o = 1 },
  { "compat41",			&shell_compatibility_level,	.get_func = get_compatibility_level,	.set_func = set_compatibility_level,	.reference_value = 41,	.hide_set_o = 1 },
  { "compat42",			&shell_compatibility_level,	.get_func = get_compatibility_level,	.set_func = set_compatibility_level,	.reference_value = 42,	.hide_set_o = 1 },
  { "compat43",			&shell_compatibility_level,	.get_func = get_compatibility_level,	.set_func = set_compatibility_level,	.reference_value = 43,	.hide_set_o = 1 },
  { "compat44",			&shell_compatibility_level,	.get_func = get_compatibility_level,	.set_func = set_compatibility_level,	.reference_value = 44,	.hide_set_o = 1 },
  { "compat50",			&shell_compatibility_level,	.get_func = get_compatibility_level,	.set_func = set_compatibility_level,	.reference_value = 50,	.hide_set_o = 1 },
  { "compat51",			&shell_compatibility_level,	.get_func = get_compatibility_level,	.set_func = set_compatibility_level,	.reference_value = 51,	.hide_set_o = 1 },
  { "compat52",			&shell_compatibility_level,	.get_func = get_compatibility_level,	.set_func = set_compatibility_level,	.reference_value = 52,	.hide_set_o = 1 },
  { "compat53",			&shell_compatibility_level,	.get_func = get_compatibility_level,	.set_func = set_compatibility_level,	.reference_value = 53,	.hide_set_o = 1 },
  { "compat54",			&shell_compatibility_level,	.get_func = get_compatibility_level,	.set_func = set_compatibility_level,	.reference_value = 54,	.hide_set_o = 1 },
#if defined (READLINE)
  { "complete_fullquote",	&complete_fullquote,	.hide_set_o = 1,	.init = one },
  { "direxpand",		&dircomplete_expand,	.set_func = shopt_set_complete_direxpand,	.hide_set_o = 1,	.init = DIRCOMPLETE_EXPAND_INIT },
  { "dirspell",			&dircomplete_spelling,	.hide_set_o = 1,	.init = zero },
#endif
  { "dotglob",			&glob_dot_filenames,	.hide_set_o = 1,	.init = zero },
#if defined (READLINE)
  { "emacs",						.set_func = set_edit_mode,	.get_func = get_edit_mode,	.reference_value = EMACS_EDITING_MODE,	.hide_shopt = 1 },
#endif
  { "errexit",			&errexit_flag,		.letter = 'e',	.set_func = set_errexit_flag,	.hide_shopt = 1 },
  { "errtrace",			&error_trace_mode,	.letter = 'E',	.hide_shopt = 1 },
  { "execfail",			&no_exit_on_failed_exec,	.hide_set_o = 1,	.init = zero },
  { "expand_aliases",		&expaliases_flag,	.set_func = shopt_set_expaliases,	.hide_set_o = 1,	.init = zero },
#if defined (DEBUGGER)
  { "extdebug",			&debugging_mode,	.set_func = shopt_set_debug_mode,	.hide_set_o = 1,	.init = zero },
#endif
#if defined (EXTENDED_GLOB)
  { "extglob",			&extglob_flag,		.set_func = shopt_set_extglob,	.hide_set_o = 1,	.init = &(int){EXTGLOB_DEFAULT} },
#endif
  { "extquote",			&extended_quote,	.hide_set_o = 1,	.init = one },
  { "failglob",			&fail_glob_expansion,	.hide_set_o = 1,	.init = zero },
#if defined (READLINE)
  { "force_fignore",		&force_fignore,	.hide_set_o = 1,	.init = one },
#endif
  { "functrace",		&function_trace_mode,	.letter = 'T',	.hide_shopt = 1 },
  { "globasciiranges",		&glob_asciirange,	.hide_set_o = 1,	.init = &(int){GLOBASCII_DEFAULT} },
  { "globskipdots",		&glob_always_skip_dot_and_dotdot,	.hide_set_o = 1,	.init = one },
  { "globstar",			&glob_star,	.hide_set_o = 1,	.init = zero },
  { "gnu_errfmt",		&gnu_error_format,	.hide_set_o = 1,	.init = zero },
  { "hashall",			&hashing_enabled,	.letter = 'h',	.hide_shopt = 1 },
#if defined (HISTORY)
  { "histappend",		&force_append_history,	.hide_set_o = 1,	.init = zero },
#endif
#if defined (BANG_HISTORY)
  { "histexpand",		&histexp_flag,		.letter = 'H',	.set_func = set_histexp_flag,	.hide_shopt = 1 },
#endif /* BANG_HISTORY */
#if defined (HISTORY)
  { "history",			&enable_history_list,	.set_func = bash_set_history,	.hide_shopt = 1,	.init = one },
#endif
#if defined (READLINE) && defined (HISTORY)
  { "histreedit",		&history_reediting,	.hide_set_o = 1,	.init = zero },
  { "histverify",		&hist_verify,	.hide_set_o = 1,	.init = zero },
  { "hostcomplete",		&perform_hostname_completion,	.set_func = shopt_enable_hostname_completion,	.hide_set_o = 1,	.init = one },
#endif
  { "huponexit",		&hup_on_exit,	.hide_set_o = 1,	.init = zero },
  { "ignoreeof",		&ignoreeof,		.set_func = set_ignoreeof,	.hide_shopt = 1,	.init = zero },
  { "inherit_errexit",		&inherit_errexit,	.hide_set_o = 1,	.init = zero },
  { "interactive-comments",	&interactive_comments,	.adjust_shellopts = 1,	.hide_shopt = 1,	.init = one },
  { "interactive_comments",	&interactive_comments,	.adjust_shellopts = 1,	.hide_set_o = 1 },
  { "keyword",			&place_keywords_in_env,	.letter = 'k',	.hide_shopt = 1 },
  { "lastpipe",			&lastpipe_opt,	.hide_set_o = 1,	.init = zero },
#if defined (HISTORY)
  { "lithist",			&literal_history,	.hide_set_o = 1,	.init = zero },
#endif
  { "localvar_inherit",		&localvar_inherit,	.hide_set_o = 1,	.init = zero },
  { "localvar_unset",		&localvar_unset,	.hide_set_o = 1,	.init = zero },
  { "login_shell",		&login_shell,		.ignore_change = 1,	.hide_set_o = 1 },
  { "mailwarn",			&mail_warning,	.hide_set_o = 1,	.init = zero },
#if defined (JOB_CONTROL)
  { "monitor",			&jobs_m_flag,		.letter = 'm',	.set_func = set_monitor_flag,	.hide_shopt = 1 },
#endif
#if defined (READLINE)
  { "no_empty_cmd_completion",	&no_empty_command_completion,	.hide_set_o = 1,	.init = zero },
#endif
  { "nocaseglob",		&glob_ignore_case,	.hide_set_o = 1,	.init = zero },
  { "nocasematch",		&match_ignore_case,	.hide_set_o = 1,	.init = zero },
  { "noclobber",		&noclobber,		.letter = 'C',	.hide_shopt = 1 },
  { "noexec",			&read_but_dont_execute,	.letter = 'n',	.set_func = set_noexec_flag,	.hide_shopt = 1 },
  { "noexpand_translation",	&singlequote_translations,	.hide_set_o = 1,	.init = zero },
  { "noglob",			&disallow_filename_globbing,	.letter = 'f',	.hide_shopt = 1 },
#if defined (HISTORY)
  { "nolog",			&dont_save_function_defs,	.hide_shopt = 1,	.init = zero },
#endif
#if defined (JOB_CONTROL)
  { "notify",			&asynchronous_notification,	.letter = 'b',	.hide_shopt = 1 },
#endif /* JOB_CONTROL */
  { "nounset",			&unbound_vars_is_error,	.letter = 'u',	.hide_shopt = 1 },
  { "nullglob",			&allow_null_glob_expansion,	.hide_set_o = 1,	.init = zero },
  { "onecmd",			&just_one_command,	.letter = 't',	.hide_shopt = 1 },
  { "patsub_replacement",	&patsub_replacement,	.hide_set_o = 1,	.init = &(int){PATSUB_REPLACE_DEFAULT} },
  { "physical",			&no_symbolic_links,	.letter = 'P',	.hide_shopt = 1 },
  { "pipefail",			&pipefail_opt,	.hide_shopt = 1,	.init = zero },
  { "posix",			&posixly_correct,	.set_func = set_posix_mode,	.hide_shopt = 1,	.init = (int[]){POSIXLY_CORRECT_INIT} },
  { "privileged",		&privileged_mode,	.letter = 'p',	.set_func = set_privileged_flag,	.hide_shopt = 1 },
#if defined (PROGRAMMABLE_COMPLETION)
  { "progcomp",			&prog_completion_enabled,	.hide_set_o = 1,	.init = one },
#  if defined (ALIAS)
  { "progcomp_alias",		&progcomp_alias,	.hide_set_o = 1,	.init = zero },
#  endif
#endif
  { "promptvars",		&promptvars,	.hide_set_o = 1,	.init = one },
#if defined (RESTRICTED_SHELL)
  { "restricted_shell",		&restricted_shell,	.set_func = set_restricted_shell,	.hide_set_o = 1 },
#endif
  { "shift_verbose",		&print_shift_error,	.hide_set_o = 1,	.init = zero },
  { "sourcepath",		&source_uses_path,	.hide_set_o = 1,	.init = one },
#if defined (SYSLOG_HISTORY) && defined (SYSLOG_SHOPT)
  { "syslog_history",		&syslog_history,	.hide_set_o = 1,	.init = (int[]){SYSLOG_HISTORY_INIT} },
#endif
  { "varredir_close",		&varassign_redir_autoclose,	.hide_set_o = 1,	.init = zero },
  { "verbose",			&verbose_flag,		.letter = 'v',	.set_func = set_verbose_flag,	.hide_shopt = 1 },
#if defined (READLINE)
  { "vi",						.set_func = set_edit_mode,	.get_func = get_edit_mode,	.reference_value = VI_EDITING_MODE,	.hide_shopt = 1 },
#endif
  { "xpg_echo",			&xpg_echo,	.hide_set_o = 1,	.init = XPG_ECHO_INIT },
  { "xtrace",			&echo_command_at_execute,	.letter = 'x',	.hide_shopt = 1 },
  { no_long_name,		&forced_interactive,	.letter = 'i',	.hide_shopt = 1 },
#if defined (RESTRICTED_SHELL)
  { no_long_name,		&restricted,		.letter = 'r',	.set_func = set_restricted_flag,	.hide_shopt = 1 },
#endif /* RESTRICTED_SHELL */
#if 0
  { no_long_name,		&lexical_scoping,	.letter = 'l',	.hide_shopt = 1 },
#endif
  0
};

#define N_OPTIONS		(sizeof (opt_defs) / sizeof (opt_defs[0]) - 1)

/******************************************************************************/

static opt_def_t const *
find_option (char const *name)
{
  opt_def_t const *d;
  for (d = opt_defs; d->name; d++)
    if (d->name != no_long_name && !strcmp (name, d->name))
      return d;
  return NULL;
}

static void
show_one_option (opt_def_t const *d,
		 optset_whence_t whence,
		 optset_whence_t display_style)
{
  show_map[WhenceC (display_style)](d, whence);
}

static void
show_one_option_unless_value (opt_def_t const *d,
			      optset_whence_t whence,
			      unsigned hide_value_mask,
			      optset_whence_t display_style)
{
  if (hide_value_mask & (1 << get_opt_value (d, whence)))
    show_map[WhenceC (display_style)](d, whence);
}

static void
list_all_options (optset_whence_t whence_selection,
		  unsigned hide_value_mask,
		  optset_whence_t display_style)
{
  _Bool (*hide_when)(opt_def_t const *d) =  hide_when_map[WhenceC (whence_selection)];
  void (*show_how)(opt_def_t const *, optset_whence_t) = show_map[WhenceC (display_style)];

  for (opt_def_t const *d = opt_defs; d->name; d++)
    {
      /* Hide options that aren't in the preferred group; use Whence (any) when you want ALL of them */
      if (hide_when && hide_when (d))
	continue;

      /* Hide options that don't have an appropriate kind of name (short or long) */
      if (WhenceC (display_style) == Whence_short
	    ? d->letter == 0
	    : d->name == no_long_name)
	continue;

      if (hide_value_mask
       && hide_value_mask & (1 << get_opt_value (d, whence_selection)))
	continue;

      show_how (d, whence_selection);
    }
}

/******************************************************************************/

#define MAX_SHORT_NAMES	(1+CHAR_MAX)
static const opt_def_t *letter_map[MAX_SHORT_NAMES];

static size_t N_short_names = 0;
static char const *short_opt_names;
static char const *set_builtin_optflags;

static void
init_letter_map (void)
{
  /* Set up only once; this will have to change if we allow loadables to register new options */
  if (short_opt_names && set_builtin_optflags)
    return;
  opt_def_t const *d;
  for (d = opt_defs ; d->name; d++)
    {
      char c = d->letter;
      if (c > 0 && c < MAX_SHORT_NAMES)
	letter_map[c] = d;
	++N_short_names;
    }

  char *ep = xmalloc (N_short_names+1);
  short_opt_names = ep;
  for (size_t c = 1; c < MAX_SHORT_NAMES; ++c)
    if (letter_map[c])
      *ep++ = c;
  *ep = 0;

  set_builtin_optflags = ep = xmalloc (N_short_names+4);
  sprintf (ep, "+%so;", short_opt_names);
}

/******************************************************************************/

/******************************************************************************/

$BUILTIN set
$FUNCTION set_builtin
$SHORT_DOC set [-abefhkmnptuvxBCEHPT] [-o option-name] [--] [-] [arg ...]
Set or unset values of shell options and positional parameters.

Change the value of shell attributes and positional parameters, or
display the names and values of shell variables.

Options:
  -a  Mark variables which are modified or created for export.
  -b  Notify of job termination immediately.
  -e  Exit immediately if a command exits with a non-zero status.
  -f  Disable file name generation (globbing).
  -h  Remember the location of commands as they are looked up.
  -k  All assignment arguments are placed in the environment for a
      command, not just those that precede the command name.
  -m  Job control is enabled.
  -n  Read commands but do not execute them.
  -o option-name
      Set the variable corresponding to option-name:
          allexport    same as -a
          braceexpand  same as -B
#if defined (READLINE)
          emacs        use an emacs-style line editing interface
#endif /* READLINE */
          errexit      same as -e
          errtrace     same as -E
          functrace    same as -T
          hashall      same as -h
#if defined (BANG_HISTORY)
          histexpand   same as -H
#endif /* BANG_HISTORY */
#if defined (HISTORY)
          history      enable command history
#endif
          ignoreeof    the shell will not exit upon reading EOF
$END


#if defined (BANG_HISTORY)
static optset_result_t
set_histexp_flag ( opt_def_t const *d, optset_whence_t w, option_value_t new_value )
{
  history_expansion = histexp_flag = new_value;
  if (new_value)
    bash_initialize_history ();
  return Result (OK);
}
#endif

#if defined (JOB_CONTROL)
static optset_result_t
set_monitor_flag ( opt_def_t const *d, optset_whence_t w, option_value_t new_value )
{
  set_job_control (new_value);
  return Result (OK);
}
#endif /* JOB_CONTROL */

static optset_result_t
set_errexit_flag ( opt_def_t const *d, optset_whence_t w, option_value_t new_value )
{
  errexit_flag = new_value;
  if (builtin_ignoring_errexit == 0)
    exit_immediately_on_error = errexit_flag;
  return Result (OK);
}

static optset_result_t
set_noexec_flag ( opt_def_t const *d, optset_whence_t w, option_value_t new_value )
{
  if (interactive_shell)
    {
      read_but_dont_execute = 0;
      return Result (Ignored);
    }
  read_but_dont_execute = new_value;
  return Result (OK);
}

static optset_result_t
set_privileged_flag ( opt_def_t const *d, optset_whence_t w, option_value_t new_value )
{
  privileged_mode = new_value;
  if (!privileged_mode)
    disable_priv_mode ();
  return Result (OK);
}

#if defined (RESTRICTED_SHELL)
static optset_result_t
set_restricted_flag ( opt_def_t const *d, optset_whence_t w, option_value_t new_value )
{
  /* Don't allow "set +r" in a shell which is `restricted'. */
  if (restricted && !new_value)
    return Result (Forbidden);

  restricted = new_value;
  if (new_value && shell_initialized)
    maybe_make_restricted (shell_name);
  return Result (OK);
}
#endif

static optset_result_t
set_verbose_flag ( opt_def_t const *d, optset_whence_t w, option_value_t new_value )
{
  echo_input_at_read = verbose_flag = new_value;
  return Result (OK);
}


/* Change the state of a flag, and return its original value, or return
   FLAG_ERROR if there is no flag FLAG.  ON_OR_OFF must be either
   FLAG_ON or FLAG_OFF. */
int
change_flag (char letter, char on_or_off)
{
  int old_value;

  if (! valid_flag (on_or_off))
    return FLAG_ERROR;

  init_letter_map ();	/* make sure the map is ready */

  opt_def_t const *d = letter_map[letter];
  if (d == NULL)
    return FLAG_ERROR;

  old_value = get_opt_value (d, Whence (short));
  optset_result_t r = set_opt_value (d, Whence (short), flag_to_bool (on_or_off));

  if (BadResult (r))
    return FLAG_ERROR;

  return (old_value);
}

/* Return a string which is the names of all the currently
   set shell flags. */
char *
which_set_flags (void)
{
  char *endp;
  char *result = endp = xmalloc (1 + N_short_names + read_from_stdin + want_pending_command);

  for (char const *cp = short_opt_names; *cp; ++cp)
    {
      opt_def_t const *d = letter_map[*cp];
      if (get_opt_value (d, Whence (short)) > 0)
	*endp++ = *cp;
    }

  if (want_pending_command)
    *endp++ = 'c';
  if (read_from_stdin)
    *endp++ = 's';

  *endp = 0;
  return result;
}

/* exported to and used by test.c */
int
minus_o_option_value (char const *name)
{
  return get_opt_value (find_option (name), Whence (set_o));
}

/* exported to and used by shell.c */
void
list_minus_o_opts (_Bool reusable)
{
  list_all_options (Whence (set_o),
		    0,
		    reusable ? Whence (set_o) : Whence (any));
}

/* get_minus_o_opts is used by pcomplete.c */

char const *const*
get_minus_o_opts (void)
{
  char const **ret;
  int i;

  ret = (char const **)strvec_create (N_OPTIONS + 1);
  opt_def_t const *d;
  for (d = opt_defs, i = 0; d->name; d++)
    {
      if (d->hide_set_o)
	continue;
      ret[i++] = (char*) d->name;	/* TODO: allow const to propagate better */
    }
  ret[i] = (char *)NULL;
  return ret;
}

/* Used by declare.def */

char *
get_current_options (void)
{
  char *ret, *endp;
  opt_def_t const *d;
  size_t num_posixopts;

  num_posixopts = num_posix_options ();	/* shopts modified by posix mode */
  /* Make the buffer big enough to hold the set -o options and the shopt
     options modified by posix mode. */
  ret = endp = xmalloc (1 + N_OPTIONS + num_posixopts);
  for (d = opt_defs; d->name; d++)
    *endp++ = bool_to_flag (get_opt_value (d, Whence (set_o)));

  /* Add the shell options that are modified by posix mode to the end of the
     bitmap. They will be handled in set_current_options () */
  get_posix_options (endp);
  endp[num_posixopts] = '\0';
  return ret;
}

void
set_current_options (const char *bitmap)
{
  if (bitmap == 0)
    return;

  opt_def_t const *d;
  char const *ptr = bitmap;

  for (d = opt_defs; d->name; d++)
    {
      option_value_t v = flag_to_bool (*ptr++);
      option_value_t cv = get_opt_value (d, Whence (set_o));
      if (v != cv)
	set_opt_value (d, Whence (set_o), v);
    }

  /* Now reset the variables changed by posix mode */
  set_posix_options (ptr);
}

static optset_result_t
set_ignoreeof (opt_def_t const *d, optset_whence_t w, option_value_t on_or_off)
{
  ignoreeof = on_or_off;
  unbind_variable_noref ("ignoreeof");
  if (ignoreeof)
    bind_variable ("IGNOREEOF", "10", 0);
  else
    unbind_variable_noref ("IGNOREEOF");
  sv_ignoreeof ("IGNOREEOF");
  return Result (OK);
}

static optset_result_t
set_posix_mode (opt_def_t const *d, optset_whence_t w, option_value_t on_or_off)
{
  /* short-circuit on no-op */
  if (on_or_off == posixly_correct)
    return Result (OK);

  posixly_correct = on_or_off;
  if (!posixly_correct)
    unbind_variable_noref ("POSIXLY_CORRECT");
  else
    bind_variable ("POSIXLY_CORRECT", "y", 0);
  sv_strict_posix ("POSIXLY_CORRECT");
  return Result (OK);
}

#if defined (READLINE)
/* Magic.  This code `knows' how readline handles rl_editing_mode. */
static optset_result_t
set_edit_mode (opt_def_t const *d, optset_whence_t w, option_value_t new_value)
{
  _Bool really_interactive = interactive && command_execution_string == NULL;
  if (new_value)
    {
      rl_variable_bind ("editing-mode", d->name);
      if (really_interactive)
	with_input_from_stdin ();
    }
  else if (rl_editing_mode == d->reference_value)
    {
      if (really_interactive)
	with_input_from_stream (stdin, "stdin");
    }
  no_line_editing = !new_value;
  return Result (OK);
}

static option_value_t
get_edit_mode (opt_def_t const *d, optset_whence_t w)
{
  return no_line_editing == 0 && rl_editing_mode == d->reference_value;
}
#endif /* READLINE */

#if defined (HISTORY)
static optset_result_t
bash_set_history (opt_def_t const *d, optset_whence_t w, option_value_t new_value)
{
  enable_history_list = new_value;
  if (new_value)
    {
      bash_history_enable ();
      if (history_lines_this_session == 0)
	load_history ();
    }
  else
    bash_history_disable ();
  return Result (OK);
}
#endif

int
set_minus_o_option (char on_or_off, char *option_name)
{
  opt_def_t const *d = find_option (option_name);

  if (!d)
    {
      sh_invalidoptname (option_name);
      return (EX_USAGE);
    }

  optset_result_t r = set_opt_value (d, Whence (set_o), flag_to_bool (on_or_off));
  if (BadResult (r))
    {
      sh_invalidoptname (option_name);
      return (EXECUTION_FAILURE);
    }
  return (EXECUTION_SUCCESS);
}

static void
print_all_shell_variables (void)
{
  SHELL_VAR **vars;

  vars = all_shell_variables ();
  if (vars)
    {
      print_var_list (vars);
      free (vars);
    }

  /* POSIX.2 does not allow function names and definitions to be output when
     `set' is invoked without options (PASC Interp #202). */
  if (posixly_correct == 0)
    {
      vars = all_shell_functions ();
      if (vars)
	{
	  print_func_list (vars);
	  free (vars);
	}
    }
}

void
set_shellopts (void)
{
  char tflag[N_OPTIONS];
  size_t ti;
  size_t vsize = 0;
  SHELL_VAR *var;
  opt_def_t const *d;

  for (d = opt_defs, ti = 0; d->name; d++)
    {
      if (d->hide_set_o)
	continue;
      option_value_t v = get_opt_value (d, Whence (set_o));
      if (v > 0)
	vsize += strlen (d->name) + 1;
      tflag[ti++] = v;
    }

  char *value = xmalloc (vsize + 1);
  char *vend = value;

  for (d = opt_defs, ti = 0; d->name; d++)
    {
      if (d->hide_set_o)
	continue;
      if (tflag[ti++])
	{
	  vend = stpcpy (vend, d->name);
	  *vend++ = ':';
	}
    }

  if (vend > value)
    vend--;			/* cut off trailing colon */
  *vend = '\0';

  /* ASS_FORCE so we don't have to temporarily turn off readonly;
   * ASS_NOMARK so we don't tickle `set -a`. */
  var = bind_variable ("SHELLOPTS", value, ASS_FORCE | ASS_NOMARK);

  /* Turn the read-only attribute back on. */
  VSETATTR (var, att_readonly);

  free (value);
}

static void
get_shellopts (void)
{
  /* set up any shell options we may have inherited. */
  SHELL_VAR *var = find_variable ("SHELLOPTS");
  if (var == NULL) return;
  if (! imported_p (var)) return;
  if (! array_p (var) && ! assoc_p (var)) return;

  char *shellopts_env = savestring (value_cell (var));
  if (shellopts_env == NULL) return;

  char *vname;
  int vptr = 0;

  for (; vname = extract_colon_unit (shellopts_env, &vptr); free (vname))
    {
      opt_def_t const *d = find_option (vname);
      if (!d) continue;

      optset_result_t r = set_opt_value (d, Whence (environ), true);
      if (BadResult (r))
	sh_invalidoptname (vname);
    }
  free (shellopts_env);
}

void
initialize_shell_options (int no_shellopts)
{
  init_letter_map ();

  if (! no_shellopts)
    get_shellopts ();
  if (! no_shellopts)
    get_shellopts ();

  /* Set up the $SHELLOPTS variable. */
  set_shellopts ();
}

/* Reset the values of the -o options that are not also shell flags.  This is
   called from initialize_subshell () in execute_cmd.c when setting up a
   subshell to run an executable shell script without a leading `#!'. */
void
reset_shell_options (void)
{
  for (opt_def_t const *d = opt_defs; d->name; d++)
    if (d->init)
      *d->store = *d->init;

#if defined (ARRAY_VARS)
  array_expand_once = 0;	/* XXX not in opt_defs */
#endif
#if defined (EXTENDED_GLOB)
  extended_glob = extglob_flag;	/* XXX extended_glob not in opt_defs; extglob_flag already set */
#endif
#if defined (HISTORY)
  remember_on_history = 1;	/* XXX not in opt_defs */
#endif
}

/* Set some flags from the word values in the input list.  If LIST is empty,
   then print out the values of the variables instead.  If LIST contains
   non-flags, then set $1 - $9 to the successive words of LIST. */
int
set_builtin (WORD_LIST *list)
{
  _Bool force_assignment = false, opts_changed = false;
  int flag_name, rv;

  if (list == NULL)
    {
      print_all_shell_variables ();
      return (sh_chkwrite (EXECUTION_SUCCESS));
    }

  /* Check validity of flag arguments. */
  rv = EXECUTION_SUCCESS;
  reset_internal_getopt ();
  while ((flag_name = internal_getopt (list, set_builtin_optflags)) != -1)
    {
      switch (flag_name)
	{
	  case 'i':	/* don't allow set -i */
	    sh_invalidopt ((char[]){ list_opttype, flag_name, 0 });
	    builtin_usage ();
	    return (EX_USAGE);
	  CASE_HELPOPT;
	  case '?':
	    builtin_usage ();
	    return (list_optopt == '?' ? EXECUTION_SUCCESS : EX_USAGE);
	  default:
	    break;
	}
    }

  /* Do the set command.  While the list consists of words starting with
     '-' or '+' treat them as flags, otherwise, start assigning them to
     $1 ... $n. */
  for (; list; list = list->next)
    {
      char *arg = list->word->word;

      /* If the argument is `--' or `-' then signal the end of the list
	and remember the remaining arguments. */
      if (arg[0] == '-' && (!arg[1] || (arg[1] == '-' && !arg[2])))
	{
	  list = list->next;

	  /* `set --' unsets the positional parameters. */
	  if (arg[1] == '-')
	    force_assignment = true;

	  /* Until told differently, the old shell behaviour of
	     `set - [arg ...]' being equivalent to `set +xv [arg ...]'
	     stands.  Posix.2 says the behaviour is marked as obsolescent. */
	  else
	    {
	      echo_command_at_execute = false;	/* change_flag ('x', FLAG_OFF); */
	      verbose_flag = false;		/* change_flag ('v', FLAG_OFF); */
	      opts_changed = true;
	    }

	  break;
	}

      char on_or_off = *arg;

      if (!valid_flag (on_or_off))
	break;

      while (arg && (flag_name = *++arg))
	{
	  if (flag_name == '?')
	    {
	      builtin_usage ();
	      return (EXECUTION_SUCCESS);
	    }

	  char *option_name = NULL;
	  if (flag_name == 'o') /* -+o option-name */
	    {
	      _Bool reusable = !flag_to_bool (on_or_off);

	      if (arg[1])
		{
		  /* allow the option name to cuddle on the end of the -o or +o */
		  option_name = arg+1;
		  arg = NULL;
		}
	      else if (list->next)
		{
		  /* If the following arg starts with '+' or '-', assume it's
		   * not an option name; otherwise consume the next arg */
		  option_name = list->next->word->word;
		  if (valid_flag (*option_name))
		    option_name = NULL;
		  else
		    list = list->next; /* Skip over option name. */
		}

	      if (option_name == NULL || *option_name == '\0')
		{
		  list_all_options (Whence (set_o),
				    0,
				    reusable ? Whence (set_o) : Whence (any));
		  continue;
		}
	    }

	  char short_option_name[] = { on_or_off, flag_name, 0 };
	  opt_def_t const *d;
	  if (option_name)
	    d = find_option (option_name);
	  else
	    {
	      option_name = short_option_name;
	      init_letter_map ();	/* make sure the map is ready */
	      d = letter_map[flag_name];
	    }

	  if (d)
	    {

	      optset_whence_t selection = option_name ? Whence (set_o) : Whence (short);
	      _Bool new_value = flag_to_bool (on_or_off);
	      optset_result_t r = set_opt_value (d, selection, new_value);
	      if (GoodResult (r)) /* any valid result */
		{
		  if (ResultC (r) == Result_OK)	/* not Result_unchanged nor Result_ignored */
		    opts_changed = true;
		  continue;
		}
	    }

	  sh_invalidoptname (option_name);
	  if (opts_changed)
	    set_shellopts ();
	  return EX_USAGE;
	}
    }

  /* Assigning $1 ... $n */
  if (list || force_assignment)
    remember_args (list, 1);
  /* Set up new value of $SHELLOPTS */
  if (opts_changed)
    set_shellopts ();
  return (rv);
}

$BUILTIN unset
$FUNCTION unset_builtin
$SHORT_DOC unset [-f] [-v] [-n] [name ...]
Unset values and attributes of shell variables and functions.

For each NAME, remove the corresponding variable or function.

Options:
  -f	treat each NAME as a shell function
  -v	treat each NAME as a shell variable
  -n	treat each NAME as a name reference and unset the variable itself
		rather than the variable it references

Without options, unset first tries to unset a variable, and if that fails,
tries to unset a function.

Some variables cannot be unset; also see `readonly'.

Exit Status:
Returns success unless an invalid option is given or a NAME is read-only.
$END

#define NEXT_VARIABLE()	any_failed++; list = list->next; continue;

#define RESTORE_NAME() \
do { \
  tname = name + strlen (name); \
  if (tname == t - 1)	/* probably a paranoid check */ \
    { \
      tname[0] = '['; \
      t[strlen (t)] = ']'; \
    } \
} while (0)

int
unset_builtin (WORD_LIST *list)
{
  int unset_function, unset_variable, unset_array, opt, nameref, any_failed;
  int global_unset_func, global_unset_var, vflags, base_vflags, valid_id;
  int posix_utility_error;
  char *name, *tname;

  unset_function = 0;
  unset_variable = 0;
  unset_array = 0;
  nameref = 0;
  posix_utility_error = 0;
  any_failed = 0;
  global_unset_func = 0;
  global_unset_var = 0;

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "fnv")) != -1)
    {
      switch (opt)
	{
	case 'f':
	  global_unset_func = 1;
	  break;
	case 'v':
	  global_unset_var = 1;
	  break;
	case 'n':
	  nameref = 1;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }

  list = loptend;

  if (global_unset_func && global_unset_var)
    {
      builtin_error (_("cannot simultaneously unset a function and a variable"));
      return (EXECUTION_FAILURE);
    }
  else if (unset_function && nameref)
    nameref = 0;

#if defined (ARRAY_VARS)
  base_vflags = array_expand_once ? VA_NOEXPAND : 0;
#endif

  while (list)
    {
      SHELL_VAR *var;
      int tem;
#if defined (ARRAY_VARS)
      char *t;
#endif

      name = list->word->word;

      unset_function = global_unset_func;
      unset_variable = global_unset_var;

#if defined (ARRAY_VARS)
      vflags = builtin_arrayref_flags (list->word, base_vflags);
      unset_array = 0;
      /* XXX valid array reference second arg was 0 */
      /* XXX tokenize_array_reference modifies NAME if it succeeds */
      if (unset_function == 0 && nameref == 0 && tokenize_array_reference (name, vflags, &t))
	unset_array = 1;
#endif

      /* Get error checking out of the way first.  The low-level functions
	just perform the unset, relying on the caller to verify. */
      valid_id = valid_identifier (name);

      /* Whether or not we are in posix mode, if neither -f nor -v appears,
	skip over trying to unset variables with invalid names and just
	treat them as potential shell function names. */
      if (global_unset_func == 0 && global_unset_var == 0 && valid_id == 0)
	{
#if defined (ARRAY_VARS)
	  if (unset_array)
	    RESTORE_NAME ();
#endif
	  unset_variable = unset_array = 0;
	  unset_function = 1;
	}

      /* Bash allows functions with names which are not valid identifiers
	to be created when not in posix mode, so check only when in posix
	mode when unsetting a function. */
      if (unset_function == 0 && valid_id == 0)
	{
	  sh_invalidid (name);
	  posix_utility_error++;
	  NEXT_VARIABLE ();
	}

      /* Search for functions here if -f supplied or if NAME cannot be a
	variable name. */
      var = unset_function ? find_function (name)
			   : (nameref ? find_variable_last_nameref (name, 0) : find_variable (name));

      /* Some variables (but not functions yet) cannot be unset, period. */
      if (var && unset_function == 0 && non_unsettable_p (var))
	{
	  builtin_error (_("%s: cannot unset"), name);
	  posix_utility_error++;
	  NEXT_VARIABLE ();
	}

      /* if we have a nameref we want to use it */
      if (var && unset_function == 0 && nameref == 0 && STREQ (name, name_cell (var)) == 0)
	name = name_cell (var);

      /* Posix.2 says try variables first, then functions.  If we would
	find a function after unsuccessfully searching for a variable,
	note that we're acting on a function now as if -f were
	supplied.  The readonly check below takes care of it. */
      if (var == 0 && nameref == 0 && unset_variable == 0 && unset_function == 0)
	{
#if defined (ARRAY_VARS)
	  /* We modified NAME in the call to tokenize_array_reference, so we
	     need to restore it here. We turned the original `[' and `]' into
	     NULL, to isolate the array name and subscript. This only happens
	     if tokenize_array_reference succeeds with a non-NULL subscript
	     pointer, and UNSET_ARRAY is set to 1 only in this case. */
	  if (unset_array)
	    {
	      RESTORE_NAME ();
	      unset_array = 0;
	    }
#endif
	  if (var = find_function (name))
	    unset_function = 1;
	}

      /* Posix.2 says that unsetting readonly variables is an error. */
      if (var && readonly_p (var))
	{
	  builtin_error (_("%s: cannot unset: readonly %s"),
			var->name, unset_function ? "function" : "variable");
	  posix_utility_error++;
	  NEXT_VARIABLE ();
	}

      /* Unless the -f option is supplied, the name refers to a variable. */
#if defined (ARRAY_VARS)
      if (var && unset_array)
	{
	  if (shell_compatibility_level <= 51)
	    vflags |= VA_ALLOWALL;

	  /* Let unbind_array_element decide what to do with non-array vars */
	  tem = unbind_array_element (var, t, vflags);	/* XXX new third arg */
	  if (tem == -2 && array_p (var) == 0 && assoc_p (var) == 0)
	    {
	      builtin_error (_("%s: not an array variable"), var->name);
	      NEXT_VARIABLE ();
	    }
	  else if (tem < 0)
	    any_failed++;
	}
      else
#endif /* ARRAY_VARS */
      /* If we're trying to unset a nameref variable whose value isn't a set
	variable, make sure we still try to unset the nameref's value */
      if (var == 0 && nameref == 0 && unset_function == 0)
	{
	  var = find_variable_last_nameref (name, 0);
	  if (var && nameref_p (var))
	    {
#if defined (ARRAY_VARS)
	      if (valid_array_reference (nameref_cell (var), 0))
		{
		  int len;

		  tname = savestring (nameref_cell (var));
		  tem = 0;
		  if (var = array_variable_part (tname, 0, &t, &len))
		    {
		      /* change to what unbind_array_element now expects */
		      if (t[len - 1] == ']')
			t[len - 1] = 0;
		      tem = unbind_array_element (var, t, vflags);	/* XXX new third arg */
		    }
		  free (tname);
		}
	      else
#endif
		tem = unbind_variable (nameref_cell (var));
	    }
	  else if (posixly_correct && var && tempvar_p (var))
	    tem = posix_unbind_tempvar (name);
	  else
	    tem = unbind_variable (name);
	}
      else if (posixly_correct && unset_function == 0 && nameref == 0 && var && tempvar_p (var))
	tem = posix_unbind_tempvar (name);
      else
	tem = unset_function ? unbind_func (name) : (nameref ? unbind_nameref (name) : unbind_variable (name));

      /* This is what Posix.2 says:  ``If neither -f nor -v
	is specified, the name refers to a variable; if a variable by
	that name does not exist, it is unspecified whether  a function
	by that name, if any, shall be unset.'' The unspecified part is a
	recent addition, so we continue to try to unset a shell function if
	we don't find a variable named NAME. */
      if (tem == -1 && nameref == 0 && unset_function == 0 && unset_variable == 0)
	tem = unbind_func (name);

      name = list->word->word;		/* reset above for namerefs */

      /* SUSv3, POSIX.1-2001 say:  ``Unsetting a variable or function that
	was not previously set shall not be considered an error.'' */

      if (unset_function == 0)
	stupidly_hack_special_variables (name);

      list = list->next;
    }

  return (any_failed ? (posix_utility_error ? EX_UTILERROR : EXECUTION_FAILURE) : EXECUTION_SUCCESS);
}

$BUILTIN shopt
$FUNCTION shopt_builtin
$SHORT_DOC shopt [-pqsu] [-o] [optname ...]
Set and unset shell options.

Change the setting of each shell option OPTNAME.  Without any option
arguments, list each supplied OPTNAME, or all shell options if no
OPTNAMEs are given, with an indication of whether or not each is set.

Options:
  -o	restrict options to those defined for use with ‘set -o’
  -O	exclude options defined for use with ‘set -o’
  -p	print each shell option with an indication of its status
  -q	suppress output
  -s	enable (set) each OPTNAME
  -u	disable (unset) each OPTNAME

Exit Status:
Returns success if OPTNAME is enabled; fails if an invalid option is
given or OPTNAME is disabled.
$END


/* If you add a new variable name here, make sure to set the default value
   appropriately in reset_shopt_options. */

int
shopt_builtin (WORD_LIST *list)
{
  int opt;
  _Bool do_set = false;
  _Bool do_unset = false;
  _Bool quiet = false;
  _Bool reusable = false;
  _Bool fake_set_o = false;
  _Bool non_set_o = false;

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "Oopqsu")) != -1)
    {
      switch (opt)
	{
	case 'O': non_set_o  = true; break;
	case 'o': fake_set_o = true; break;
	case 'p': reusable   = true; break;
	case 'q': quiet      = true; break;
	case 's': do_set     = true; break;
	case 'u': do_unset   = true; break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  /* This has no effect now, but will select from the table */
  optset_whence_t selection = non_set_o == fake_set_o ? Whence (any)
					 : fake_set_o ? Whence (set_o)
						      : Whence (shopt);

  /* This will limit displays to only options that a designated state */
  unsigned int value_mask = do_set   ? ~(1 << true)
			  : do_unset ? ~(1 << false) : 0;

  /* This chooses the preferred display style */
  optset_whence_t display_style = ! reusable ? Whence (any)
				: fake_set_o ? Whence (set_o)
					     : Whence (shopt);

  if (list && (do_set || do_unset))
    {
      /**********************
       *		    *
       *   CHANGE OPTIONS   *
       *		    *
       **********************/

      /* shopt [-o] -s ARG...	: set each ARG */
      /* shopt [-o] -u ARG...	: unset each ARG */

      if (do_set && do_unset)
	{
	  builtin_error (_("cannot set and unset shell options simultaneously"));
	  return (EXECUTION_FAILURE);
	}

      _Bool new_value = do_set;

      int rval = EXECUTION_SUCCESS;

      for (; list; list = list->next)
	{
	  char const * option_name = list->word->word;
	  opt_def_t const *d = find_option (option_name);
	  if (!d)
	    {
	      sh_invalidoptname (option_name);
	      rval = EX_USAGE;
	      continue;
	    }
	  optset_result_t r = set_opt_value (d, selection, new_value);
	  if (BadResult (r))
	    {
	      sh_invalidoptname (option_name);
	      rval = EXECUTION_FAILURE;
	      continue;
	    }
	}
      if (fake_set_o)
	set_shellopts ();
      else
	/* Don't set $BASHOPTS here if it hasn't already been initialized */
	if (find_variable ("BASHOPTS") != NULL)
	  set_bashopts ();

      if (rval == EX_USAGE)
	builtin_usage ();
      return rval;
    }

  if (list == NULL)
    {
      /**********************
       *		    *
       *    LIST OPTIONS    *
       *		    *
       **********************/
      /* shopt [flags] (without any ARGs)
       *
       * When not given any args, always print a list, subject to some
       * constraints:
       *  -o/-O constrain the selection to match the traditional 'set -o' or 'shopt' list
       *  -p/-po causes the output to be in re-usable format
       *
       * Select options by:
       *  if (non_set_o)
       *    if (fake_set_o)
       *      (combining -o and -O does not restrict selection)
       *      if (do_set || do_unset)
       *        // shopt -Oos		: show all set options (with -p use set-o format)
       *        // shopt -Oou		: show all unset options (with -p use set-o format)
       *      else
       *        // shopt -Oo		: show all options (with -p use set-o format)
       *    else
       *      if (do_set || do_unset)
       *        // shopt -Os		: show all set non-set-o options (with -p use shopt format)
       *        // shopt -Ou		: show all unset non-set-o options (with -p use shopt format)
       *      else
       *        // shopt -O		: show all non-set-o options (with -p use shopt format)
       *  else
       *    if (fake_set_o)
       *      if (do_set || do_unset)
       *        // shopt -os		: show all set set -o options (with -p use set -o format)
       *        // shopt -ou		: show all unset set -o options (with -p use set -o format)
       *      else
       *        // shopt -o		: show all set -o options (with -p use set -o format)
       *    else
       *      if (do_set || do_unset)
       *        // shopt -s		: show all set options (with -p use shopt format)
       *        // shopt -u		: show all unset options (with -p use shopt format)
       *      else
       *        // shopt		: show all options (with -p use shopt format)
       *
       * Choose output format; only [-o] and [-p] count:
       *  if (reusable)
       *    if (fake_set_o)
       *      // shopt -po		: show using set-o format
       *    else
       *      // shopt -p		: show using shopt format
       *  else
       *    // shopt			: show using standard format
       */
      if (!quiet)
	list_all_options (selection, value_mask, display_style);

      return (sh_chkwrite (EXECUTION_SUCCESS));
    }

    {
      /******************************
       *			    *
       *  REPORT SELECTED OPTIONS   *
       *			    *
       ******************************/

      /* shopt [-o] ARG... */
      /* shopt -o OPTS... : show selected options */
      /* shopt OPTS... : show selected values */
      /* shopt -o[su] OPTS... : change selected options */
      /* shopt {-s/-u} ... */
      /* shopt {-os/-ou} ... */

      int rval = EXECUTION_SUCCESS;
      for (; list; list = list->next)
	{
	  char const * option_name = list->word->word;
	  opt_def_t const *d = find_option (option_name);
	  if (!d)
	    {
	      sh_invalidoptname (option_name);
	      rval = EX_USAGE;
	      continue;
	    }
	  if (rval == EXECUTION_SUCCESS)
	    {
	      option_value_t val = get_opt_value (d, Whence (shopt));
	      if (val == 0)
		rval = 1;	/* looks like EXECUTION_FAILURE but actually means OFF */
	    }
	  if (!quiet)
	    show_one_option (d, Whence (shopt), display_style);
	}
      if (rval == EX_USAGE)
	builtin_usage ();
      return (sh_chkwrite (rval));
    }
}

static optset_result_t
shopt_set_debug_mode (opt_def_t const *d, optset_whence_t w, option_value_t new_value)
{
  d->store[0] = new_value;
#if defined (DEBUGGER)
  error_trace_mode = function_trace_mode = debugging_mode;
  set_shellopts ();
  if (debugging_mode)
    init_bash_argv ();
#endif
  return Result (OK);
}

static optset_result_t
shopt_set_expaliases (opt_def_t const *d, optset_whence_t w, option_value_t new_value)
{
  d->store[0] = new_value;
  expand_aliases = expaliases_flag;
  return Result (OK);
}

#if defined (EXTENDED_GLOB)
static optset_result_t
shopt_set_extglob (opt_def_t const *d, optset_whence_t w, option_value_t new_value)
{
  d->store[0] = new_value;
  extended_glob = extglob_flag;
  return Result (OK);
}
#endif

#if defined (READLINE)
static optset_result_t
shopt_enable_hostname_completion (opt_def_t const *d, optset_whence_t w, option_value_t new_value)
{
  int previous_value = enable_hostname_completion (new_value);
  return Result (OK);
}
#endif

static option_value_t
get_compatibility_level (opt_def_t const *d, optset_whence_t w)
{
  return d->store[0] == d->reference_value;
}

static optset_result_t
set_compatibility_level (opt_def_t const *d, optset_whence_t w, option_value_t new_value)
{
  if (new_value)
    d->store[0] = d->reference_value;
  else if (d->store[0] == d->reference_value)
    {
      /*
       * The original code included this comment:
       *   If we're unsetting one of the compatibility options, make sure the
       *   current value is in the range of the compatNN space.
       * (which was inserted on 2022-02-15 by commit 6d69b62)
       *
       * However that's not what the code did, so absent any other rationale,
       * we do this instead:
       *
       *   If unsetting the current level, set the current level to the default
       *   level; if unsetting some other level, do nothing.
       */
      #if 0
      int current_level = d->store[0];
      if (current_level > DEFAULT_COMPAT_LEVEL || current_level <= 44)
      #endif
	d->store[0] = DEFAULT_COMPAT_LEVEL;
    }

  /* Make sure the current compatibility level is reflected in BASH_COMPAT */
  char *rhs = itos (shell_compatibility_level);
  bind_variable ("BASH_COMPAT", rhs, 0);
  free (rhs);

  return Result (OK);
}

#if defined (READLINE)
static optset_result_t
shopt_set_complete_direxpand (opt_def_t const *d, optset_whence_t w, option_value_t new_value)
{
  d->store[0] = new_value;
  set_directory_hook ();
  return Result (OK);
}
#endif

#if defined (RESTRICTED_SHELL)
/* Don't allow the value of restricted_shell to be modified. */

static optset_result_t
set_restricted_shell (opt_def_t const *d, optset_whence_t w, option_value_t new_value)
{
  d->store[0] = new_value;
  static int save_restricted = -1;

  if (save_restricted == -1)
    save_restricted = shell_is_restricted (shell_name);

  restricted_shell = save_restricted;
  return Result (OK);
}
#endif /* RESTRICTED_SHELL */

/* get_shopt_options called from pcomplete.c */
char **
get_shopt_options (void)
{
  char **ret = strvec_create (N_OPTIONS + 1);
  for (size_t i = 0; opt_defs[i].name; i++)
    ret[i] = savestring (opt_defs[i].name);
  ret[N_OPTIONS] = NULL;
  return ret;
}

/*
 * External interface for other parts of the shell.  NAME is a string option;
 * NEW_VALUE is false if we want to unset an option; true if we want to set an option.
 */
int
shopt_setopt (char const *name, option_value_t new_value)
{
  opt_def_t const *d = find_option (name);
  if (!d)
    {
      sh_invalidoptname (name);
      return (EX_USAGE);
    }

  optset_result_t r = set_opt_value (d, Whence (shopt), new_value);

  set_bashopts ();

  return res_to_ex (r);
}

int
shopt_listopt (char const *name, int reusable)
{
  optset_whence_t display_style = reusable ? Whence (shopt) : Whence (any);
  if (name == NULL)
    list_all_options (Whence (any), 0, display_style);
  else
    {
      opt_def_t const *d = find_option (name);
      if (!d)
	{
	  sh_invalidoptname (name);
	  return (EXECUTION_FAILURE);
	}

      show_one_option (d, Whence (shopt), display_style);
    }
  return (sh_chkwrite (EXECUTION_SUCCESS));
}

void
set_bashopts (void)
{
  char tflag[N_OPTIONS];
  size_t ti, vsize;
  SHELL_VAR *var;
  opt_def_t const *d;

  for (d = opt_defs, vsize = ti = 0; d->name; d++)
    {
      if (d->hide_shopt)
	continue;
      option_value_t v = get_opt_value (d, Whence (shopt));
      if (v > 0)
	vsize += strlen (d->name) + 1;
      tflag[ti++] = v;
    }

  char *value = xmalloc (vsize + 1);
  char *vend = value;

  for (d = opt_defs, ti = vsize = 0; d->name; d++)
    {
      if (d->hide_shopt)
	continue;
      if (tflag[ti++])
	{
	  vend = stpcpy (vend, d->name);
	  *vend++ = ':';
	}
    }

  if (vend > value)
    vend--;			/* cut off trailing colon */
  *vend = '\0';

  /* ASS_FORCE so we don't have to temporarily turn off readonly;
   * ASS_NOMARK so we don't tickle `set -a`. */
  var = bind_variable ("BASHOPTS", value, ASS_FORCE | ASS_NOMARK);
  free (value);

  /* Turn the read-only attribute back on. */
  VSETATTR (var, att_readonly);
}

static void
get_bashopts (void)
{
  SHELL_VAR *var = find_variable ("BASHOPTS");
  /* set up any shell options we may have inherited. */

  if (! var
      || ! imported_p (var)
      || array_p (var)
      || assoc_p (var))
    return;

  char *value = savestring (value_cell (var));
  if (!value) return;

  char *vname;
  int vptr = 0;
  while (vname = extract_colon_unit (value, &vptr))
    {
      (void) set_opt_value (find_option (vname), Whence (environ), true);
      /* Ignore return status; don't care about unknown shopt names */
      free (vname);
    }
  free (value);
}

void
initialize_bashopts (int no_bashopts)
{
  init_letter_map ();

  if (!no_bashopts)
    get_bashopts ();

  /* Set up the $BASHOPTS variable. */
  set_bashopts ();
}
