This file is set.def, from which is created set.c.
It implements the ‘set’, ‘shopt’, and ‘unset’ builtins in Bash.

Copyright (C) 1987-2024 Free Software Foundation, Inc.

This file is part of GNU Bash, the Bourne Again SHell.

Bash is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Bash is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Bash.  If not, see <http://www.gnu.org/licenses/>.

$PRODUCES set.c

#include <config.h>

#if defined (HAVE_UNISTD_H)
#  ifdef _MINIX
#    include <sys/types.h>
#  endif
#  include <unistd.h>
#endif

#include <stdio.h>

#include "version.h"

#include "../bashansi.h"
#include "../bashintl.h"

#include "../shell.h"
#include "../parser.h"
#include "../flags.h"
#include "common.h"
#include "bashgetopt.h"

#if defined (READLINE)
#  include "../input.h"
#  include "../bashline.h"
#  include <readline/readline.h>
#endif

#if defined (HISTORY)
#  include "../bashhist.h"
#endif

$BUILTIN set
$FUNCTION set_builtin
$SHORT_DOC set [-abefhkmnptuvxBCEHPT] [-o option-name] [--] [-] [arg ...]
Set or unset values of shell options and positional parameters.

Change the value of shell attributes and positional parameters, or
display the names and values of shell variables.

Options:
  -a  Mark variables which are modified or created for export.
  -b  Notify of job termination immediately.
  -e  Exit immediately if a command exits with a non-zero status.
  -f  Disable file name generation (globbing).
  -h  Remember the location of commands as they are looked up.
  -k  All assignment arguments are placed in the environment for a
      command, not just those that precede the command name.
  -m  Job control is enabled.
  -n  Read commands but do not execute them.
  -o option-name
      Set the variable corresponding to option-name:
          allexport    same as -a
          braceexpand  same as -B
#if defined (READLINE)
          emacs        use an emacs-style line editing interface
#endif /* READLINE */
          errexit      same as -e
          errtrace     same as -E
          functrace    same as -T
          hashall      same as -h
#if defined (BANG_HISTORY)
          histexpand   same as -H
#endif /* BANG_HISTORY */
#if defined (HISTORY)
          history      enable command history
#endif
          ignoreeof    the shell will not exit upon reading EOF
          interactive-comments
                       allow comments to appear in interactive commands
          keyword      same as -k
#if defined (JOB_CONTROL)
          monitor      same as -m
#endif
          noclobber    same as -C
          noexec       same as -n
          noglob       same as -f
          nolog        currently accepted but ignored
#if defined (JOB_CONTROL)
          notify       same as -b
#endif
          nounset      same as -u
          onecmd       same as -t
          physical     same as -P
          pipefail     the return value of a pipeline is the status of
                       the last command to exit with a non-zero status,
                       or zero if no command exited with a non-zero status
          posix        change the behavior of bash where the default
                       operation differs from the Posix standard to
                       match the standard
          privileged   same as -p
          verbose      same as -v
#if defined (READLINE)
          vi           use a vi-style line editing interface
#endif /* READLINE */
          xtrace       same as -x
  -p  Turned on whenever the real and effective user ids do not match.
      Disables processing of the $ENV file and importing of shell
      functions.  Turning this option off causes the effective uid and
      gid to be set to the real uid and gid.
  -t  Exit after reading and executing one command.
  -u  Treat unset variables as an error when substituting.
  -v  Print shell input lines as they are read.
  -x  Print commands and their arguments as they are executed.
#if defined (BRACE_EXPANSION)
  -B  the shell will perform brace expansion
#endif /* BRACE_EXPANSION */
  -C  If set, disallow existing regular files to be overwritten
      by redirection of output.
  -E  If set, the ERR trap is inherited by shell functions.
#if defined (BANG_HISTORY)
  -H  Enable ! style history substitution.  This flag is on
      by default when the shell is interactive.
#endif /* BANG_HISTORY */
  -P  If set, do not resolve symbolic links when executing commands
      such as cd which change the current directory.
  -T  If set, the DEBUG and RETURN traps are inherited by shell functions.
  --  Assign any remaining arguments to the positional parameters.
      If there are no remaining arguments, the positional parameters
      are unset.
  -   Assign any remaining arguments to the positional parameters.
      The -x and -v options are turned off.

If -o is supplied with no option-name, set prints the current shell
option settings. If +o is supplied with no option-name, set prints a
series of set commands to recreate the current option settings.

Using + rather than - causes these flags to be turned off.  The
flags can also be used upon invocation of the shell.  The current
set of flags may be found in $-.  The remaining n ARGs are positional
parameters and are assigned, in order, to $1, $2, .. $n.  If no
ARGs are given, all shell variables are printed.

Exit Status:
Returns success unless an invalid option is given.
$END

typedef int setopt_set_func_t (int, char const*);
typedef int setopt_get_func_t (char *);

static int find_minus_o_option (char *);

static void print_minus_o_option (char *, int, int);
static void print_all_shell_variables (void);

static int set_ignoreeof (int, char *);
static int set_posix_mode (int, char *);

#if defined (READLINE)
static int set_edit_mode (int, char *);
static int get_edit_mode (char *);
#endif

#if defined (HISTORY)
static int bash_set_history (int, char *);
#endif

static const char * const on = "on";
static const char * const off = "off";

static int previous_option_value;

/* A struct used to match long options for set -o to the corresponding
   option letter or internal variable.  The functions can be called to
   dynamically generate values.  If you add a new variable name here
   that doesn't have a corresponding single-character option letter, make
   sure to set the value appropriately in reset_shell_options. */
const struct {
  char *name;
  int letter;
  int *variable;
  setopt_set_func_t *set_func;
  setopt_get_func_t *get_func;
} o_options[] = {
  { "allexport",  'a', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL },
#if defined (BRACE_EXPANSION)
  { "braceexpand",'B', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
#endif
#if defined (READLINE)
  { "emacs",     '\0', (int *)NULL, set_edit_mode, get_edit_mode },
#endif
  { "errexit",	  'e', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
  { "errtrace",	  'E', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
  { "functrace",  'T', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
  { "hashall",    'h', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
#if defined (BANG_HISTORY)
  { "histexpand", 'H', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
#endif /* BANG_HISTORY */
#if defined (HISTORY)
  { "history",   '\0', &enable_history_list, bash_set_history, (setopt_get_func_t *)NULL },
#endif
  { "ignoreeof", '\0', &ignoreeof, set_ignoreeof, (setopt_get_func_t *)NULL },
  { "interactive-comments", '\0', &interactive_comments, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL },
  { "keyword",    'k', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
#if defined (JOB_CONTROL)
  { "monitor",	  'm', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
#endif
  { "noclobber",  'C', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
  { "noexec",	  'n', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
  { "noglob",	  'f', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
#if defined (HISTORY)
  { "nolog",     '\0', &dont_save_function_defs, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL },
#endif
#if defined (JOB_CONTROL)
  { "notify",	  'b', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
#endif /* JOB_CONTROL */
  { "nounset",	  'u', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
  { "onecmd",	  't', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL },
  { "physical",   'P', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
  { "pipefail",  '\0', &pipefail_opt, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
  { "posix",     '\0', &posixly_correct, set_posix_mode, (setopt_get_func_t *)NULL },
  { "privileged", 'p', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
  { "verbose",	  'v', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
#if defined (READLINE)
  { "vi",        '\0', (int *)NULL, set_edit_mode, get_edit_mode },
#endif
  { "xtrace",	  'x', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
  {(char *)NULL, 0 , (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL },
};

#define N_O_OPTIONS	(sizeof (o_options) / sizeof (o_options[0]))

#define GET_BINARY_O_OPTION_VALUE(i, name) \
  ((o_options[i].get_func) ? (*o_options[i].get_func) (name) \
			   : (*o_options[i].variable))

#define SET_BINARY_O_OPTION_VALUE(i, onoff, name) \
  ((o_options[i].set_func) ? (*o_options[i].set_func) (onoff, name) \
			   : (*o_options[i].variable = (onoff == FLAG_ON)))

static int
find_minus_o_option (char *name)
{
  register int i;

  for (i = 0; o_options[i].name; i++)
    if (STREQ (name, o_options[i].name))
      return i;
  return -1;
}

int
minus_o_option_value (char *name)
{
  register int	i;
  int *on_or_off;

  i = find_minus_o_option (name);
  if (i < 0)
    return (-1);

  if (o_options[i].letter)
    {
      on_or_off = find_flag (o_options[i].letter);
      return ((on_or_off == FLAG_UNKNOWN) ? -1 : *on_or_off);
    }
  else
    return (GET_BINARY_O_OPTION_VALUE (i, name));
}

#define MINUS_O_FORMAT "%-15s\t%s\n"

static void
print_minus_o_option (char *name, int value, int pflag)
{
  if (pflag == 0)
    printf (MINUS_O_FORMAT, name, value ? on : off);
  else
    printf ("set %co %s\n", value ? '-' : '+', name);
}

void
list_minus_o_opts (int mode, int reusable)
{
  register int	i;
  int *on_or_off, value;

  for (i = 0; o_options[i].name; i++)
    {
      if (o_options[i].letter)
	{
	  value = 0;
	  on_or_off = find_flag (o_options[i].letter);
	  if (on_or_off == FLAG_UNKNOWN)
	    on_or_off = &value;
	  if (mode == -1 || mode == *on_or_off)
	    print_minus_o_option (o_options[i].name, *on_or_off, reusable);
	}
      else
	{
	  value = GET_BINARY_O_OPTION_VALUE (i, o_options[i].name);
	  if (mode == -1 || mode == value)
	    print_minus_o_option (o_options[i].name, value, reusable);
	}
    }
}

char **
get_minus_o_opts (void)
{
  char **ret;
  int i;

  ret = strvec_create (N_O_OPTIONS + 1);
  for (i = 0; o_options[i].name; i++)
    ret[i] = o_options[i].name;
  ret[i] = (char *)NULL;
  return ret;
}

char *
get_current_options (void)
{
  char *temp;
  int i;
  size_t posixopts;

  posixopts = num_posix_options ();	/* shopts modified by posix mode */
  /* Make the buffer big enough to hold the set -o options and the shopt
     options modified by posix mode. */
  temp = (char *)xmalloc (1 + N_O_OPTIONS + posixopts);
  for (i = 0; o_options[i].name; i++)
    {
      if (o_options[i].letter)
	temp[i] = *(find_flag (o_options[i].letter));
      else
	temp[i] = GET_BINARY_O_OPTION_VALUE (i, o_options[i].name);
    }

  /* Add the shell options that are modified by posix mode to the end of the
     bitmap. They will be handled in set_current_options() */
  get_posix_options (temp+i);
  temp[i+posixopts] = '\0';
  return (temp);
}

void
set_current_options (const char *bitmap)
{
  int i, v, cv, *on_or_off;

  if (bitmap == 0)
    return;

  for (i = 0; o_options[i].name; i++)
    {
      v = bitmap[i] ? FLAG_ON : FLAG_OFF;
      if (o_options[i].letter)
	{
	  /* We should not get FLAG_UNKNOWN here */
	  on_or_off = find_flag (o_options[i].letter);
	  cv = *on_or_off ? FLAG_ON : FLAG_OFF;
	  if (v != cv)
	    change_flag (o_options[i].letter, v);
	}
      else
	{
	  cv = GET_BINARY_O_OPTION_VALUE (i, o_options[i].name);
	  cv = cv ? FLAG_ON : FLAG_OFF;
	  if (v != cv)
	    SET_BINARY_O_OPTION_VALUE (i, v, o_options[i].name);
	}
    }

  /* Now reset the variables changed by posix mode */
  set_posix_options (bitmap+i);
}

static int
set_ignoreeof (int on_or_off, char *option_name)
{
  ignoreeof = on_or_off == FLAG_ON;
  unbind_variable_noref ("ignoreeof");
  if (ignoreeof)
    bind_variable ("IGNOREEOF", "10", 0);
  else
    unbind_variable_noref ("IGNOREEOF");
  sv_ignoreeof ("IGNOREEOF");
  return 0;
}

static int
set_posix_mode (int on_or_off, char *option_name)
{
  /* short-circuit on no-op */
  if ((on_or_off == FLAG_ON && posixly_correct) ||
      (on_or_off == FLAG_OFF && posixly_correct == 0))
    return 0;

  posixly_correct = on_or_off == FLAG_ON;
  if (posixly_correct == 0)
    unbind_variable_noref ("POSIXLY_CORRECT");
  else
    bind_variable ("POSIXLY_CORRECT", "y", 0);
  sv_strict_posix ("POSIXLY_CORRECT");
  return (0);
}

#if defined (READLINE)
/* Magic.  This code `knows' how readline handles rl_editing_mode. */
static int
set_edit_mode (int on_or_off, char *option_name)
{
  int isemacs;

  if (on_or_off == FLAG_ON)
    {
      rl_variable_bind ("editing-mode", option_name);

      if (interactive && command_execution_string == 0)
	with_input_from_stdin ();
      no_line_editing = 0;
    }
  else
    {
      isemacs = rl_editing_mode == 1;
      if ((isemacs && *option_name == 'e') || (!isemacs && *option_name == 'v'))
	{
	  if (interactive && command_execution_string == 0)
	    with_input_from_stream (stdin, "stdin");
	  no_line_editing = 1;
	}
    }
  return 1-no_line_editing;
}

static int
get_edit_mode (char *name)
{
  return (*name == 'e' ? no_line_editing == 0 && rl_editing_mode == 1
		       : no_line_editing == 0 && rl_editing_mode == 0);
}
#endif /* READLINE */

#if defined (HISTORY)
static int
bash_set_history (int on_or_off, char *option_name)
{
  if (on_or_off == FLAG_ON)
    {
      enable_history_list = 1;
      bash_history_enable ();
      if (history_lines_this_session == 0)
	load_history ();
    }
  else
    {
      enable_history_list = 0;
      bash_history_disable ();
    }
  return (1 - enable_history_list);
}
#endif

int
set_minus_o_option (int on_or_off, char *option_name)
{
  register int i;

  i = find_minus_o_option (option_name);
  if (i < 0)
    {
      sh_invalidoptname (option_name);
      return (EX_USAGE);
    }

  if (o_options[i].letter == 0)
    {
      previous_option_value = GET_BINARY_O_OPTION_VALUE (i, o_options[i].name);
      SET_BINARY_O_OPTION_VALUE (i, on_or_off, option_name);
      return (EXECUTION_SUCCESS);
    }
  else
    {
      if ((previous_option_value = change_flag (o_options[i].letter, on_or_off)) == FLAG_ERROR)
	{
	  sh_invalidoptname (option_name);
	  return (EXECUTION_FAILURE);
	}
      else
	return (EXECUTION_SUCCESS);
    }
}

static void
print_all_shell_variables (void)
{
  SHELL_VAR **vars;

  vars = all_shell_variables ();
  if (vars)
    {
      print_var_list (vars);
      free (vars);
    }

  /* POSIX.2 does not allow function names and definitions to be output when
     `set' is invoked without options (PASC Interp #202). */
  if (posixly_correct == 0)
    {
      vars = all_shell_functions ();
      if (vars)
	{
	  print_func_list (vars);
	  free (vars);
	}
    }
}

void
set_shellopts (void)
{
  char *value;
  char tflag[N_O_OPTIONS];
  int i, *ip, exported;
  size_t vsize, vptr;
  SHELL_VAR *v;

  for (vsize = i = 0; o_options[i].name; i++)
    {
      tflag[i] = 0;
      if (o_options[i].letter)
	{
	  ip = find_flag (o_options[i].letter);
	  if (ip && *ip)
	    {
	      vsize += strlen (o_options[i].name) + 1;
	      tflag[i] = 1;
	    }
	}
      else if (GET_BINARY_O_OPTION_VALUE (i, o_options[i].name))
	{
	  vsize += strlen (o_options[i].name) + 1;
	  tflag[i] = 1;
	}
    }

  value = (char *)xmalloc (vsize + 1);

  for (i = vptr = 0; o_options[i].name; i++)
    {
      if (tflag[i])
	{
	  strcpy (value + vptr, o_options[i].name);
	  vptr += strlen (o_options[i].name);
	  value[vptr++] = ':';
	}
    }

  if (vptr)
    vptr--;			/* cut off trailing colon */
  value[vptr] = '\0';

  v = find_variable ("SHELLOPTS");

  /* Note whether or not the variable was exported so we can adjust after the
     assignment. */
  exported = v ? exported_p (v) : 0;

  /* ASS_FORCE so we don't have to temporarily turn off readonly */
  v = bind_variable ("SHELLOPTS", value, ASS_FORCE);

  /* Turn the read-only attribute back on, and turn off the export attribute
     if it was set implicitly by mark_modified_vars and SHELLOPTS was not
     exported before we bound the new value. */
  VSETATTR (v, att_readonly);
  if (mark_modified_vars && exported == 0 && exported_p (v))
    VUNSETATTR (v, att_exported);

  free (value);
}

void
parse_shellopts (char *value)
{
  char const *vname;
  int vptr;

  vptr = 0;
  while (vname = extract_colon_unit (value, &vptr))
    {
      set_minus_o_option (FLAG_ON, vname);
      free (vname);
    }
}

void
initialize_shell_options (int no_shellopts)
{
  char *temp;
  SHELL_VAR *var;

  if (no_shellopts == 0)
    {
      var = find_variable ("SHELLOPTS");
      /* set up any shell options we may have inherited. */
      if (var && imported_p (var))
	{
	  temp = (array_p (var) || assoc_p (var)) ? (char *)NULL : savestring (value_cell (var));
	  if (temp)
	    {
	      parse_shellopts (temp);
	      free (temp);
	    }
	}
    }

  /* Set up the $SHELLOPTS variable. */
  set_shellopts ();
}

/* Reset the values of the -o options that are not also shell flags.  This is
   called from execute_cmd.c:initialize_subshell() when setting up a subshell
   to run an executable shell script without a leading `#!'. */
void
reset_shell_options (void)
{
  pipefail_opt = 0;
  ignoreeof = 0;

  interactive_comments = 1;

#if defined (STRICT_POSIX)
  posixly_correct = 1;
#else
  posixly_correct = 0;
#endif
#if defined (HISTORY)
  dont_save_function_defs = 0;
  remember_on_history = enable_history_list = 1;	/* XXX */
#endif
}

/* Set some flags from the word values in the input list.  If LIST is empty,
   then print out the values of the variables instead.  If LIST contains
   non-flags, then set $1 - $9 to the successive words of LIST. */
int
set_builtin (WORD_LIST *list)
{
  int on_or_off, flag_name, force_assignment, opts_changed, rv, r;
  register char *arg;
  char s[3];

  if (list == 0)
    {
      print_all_shell_variables ();
      return (sh_chkwrite (EXECUTION_SUCCESS));
    }

  /* Check validity of flag arguments. */
  rv = EXECUTION_SUCCESS;
  reset_internal_getopt ();
  while ((flag_name = internal_getopt (list, optflags)) != -1)
    {
      switch (flag_name)
	{
	  case 'i':	/* don't allow set -i */
	    s[0] = list_opttype;
	    s[1] = 'i';
	    s[2] = '\0';
	    sh_invalidopt (s);
	    builtin_usage ();
	    return (EX_USAGE);
	  CASE_HELPOPT;
	  case '?':
	    builtin_usage ();
	    return (list_optopt == '?' ? EXECUTION_SUCCESS : EX_USAGE);
	  default:
	    break;
	}
    }

  /* Do the set command.  While the list consists of words starting with
     '-' or '+' treat them as flags, otherwise, start assigning them to
     $1 ... $n. */
  for (force_assignment = opts_changed = 0; list; )
    {
      arg = list->word->word;

      /* If the argument is `--' or `-' then signal the end of the list
	 and remember the remaining arguments. */
      if (arg[0] == '-' && (!arg[1] || (arg[1] == '-' && !arg[2])))
	{
	  list = list->next;

	  /* `set --' unsets the positional parameters. */
	  if (arg[1] == '-')
	    force_assignment = 1;

	  /* Until told differently, the old shell behaviour of
	     `set - [arg ...]' being equivalent to `set +xv [arg ...]'
	     stands.  Posix.2 says the behaviour is marked as obsolescent. */
	  else
	    {
	      change_flag ('x', '+');
	      change_flag ('v', '+');
	      opts_changed = 1;
	    }

	  break;
	}

      if ((on_or_off = *arg) && (on_or_off == '-' || on_or_off == '+'))
	{
	  while (flag_name = *++arg)
	    {
	      if (flag_name == '?')
		{
		  builtin_usage ();
		  return (EXECUTION_SUCCESS);
		}
	      else if (flag_name == 'o') /* -+o option-name */
		{
		  char *option_name;
		  WORD_LIST *opt;

		  opt = list->next;

		  if (opt == 0)
		    {
		      list_minus_o_opts (-1, (on_or_off == '+'));
		      rv = sh_chkwrite (rv);
		      continue;
		    }

		  option_name = opt->word->word;

		  if (option_name == 0 || *option_name == '\0' ||
		      *option_name == '-' || *option_name == '+')
		    {
		      list_minus_o_opts (-1, (on_or_off == '+'));
		      continue;
		    }
		  list = list->next; /* Skip over option name. */

		  opts_changed = 1;
		  if ((r = set_minus_o_option (on_or_off, option_name)) != EXECUTION_SUCCESS)
		    {
		      set_shellopts ();
		      return (r);
		    }
		}
	      else if (change_flag (flag_name, on_or_off) == FLAG_ERROR)
		{
		  s[0] = on_or_off;
		  s[1] = flag_name;
		  s[2] = '\0';
		  sh_invalidopt (s);
		  builtin_usage ();
		  set_shellopts ();
		  return (EXECUTION_FAILURE);
		}
	      opts_changed = 1;
	    }
	}
      else
	{
	  break;
	}
      list = list->next;
    }

  /* Assigning $1 ... $n */
  if (list || force_assignment)
    remember_args (list, 1);
  /* Set up new value of $SHELLOPTS */
  if (opts_changed)
    set_shellopts ();
  return (rv);
}

$BUILTIN unset
$FUNCTION unset_builtin
$SHORT_DOC unset [-f] [-v] [-n] [name ...]
Unset values and attributes of shell variables and functions.

For each NAME, remove the corresponding variable or function.

Options:
  -f	treat each NAME as a shell function
  -v	treat each NAME as a shell variable
  -n	treat each NAME as a name reference and unset the variable itself
		rather than the variable it references

Without options, unset first tries to unset a variable, and if that fails,
tries to unset a function.

Some variables cannot be unset; also see `readonly'.

Exit Status:
Returns success unless an invalid option is given or a NAME is read-only.
$END

#define NEXT_VARIABLE()	any_failed++; list = list->next; continue;

#define RESTORE_NAME() \
do { \
  tname = name + strlen (name); \
  if (tname == t - 1)	/* probably a paranoid check */ \
    { \
      tname[0] = '['; \
      t[strlen (t)] = ']'; \
    } \
} while (0)

int
unset_builtin (WORD_LIST *list)
{
  int unset_function, unset_variable, unset_array, opt, nameref, any_failed;
  int global_unset_func, global_unset_var, vflags, base_vflags, valid_id;
  int posix_utility_error;
  char *name, *tname;

  unset_function = unset_variable = unset_array = nameref = 0;
  posix_utility_error = any_failed = 0;
  global_unset_func = global_unset_var = 0;

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "fnv")) != -1)
    {
      switch (opt)
	{
	case 'f':
	  global_unset_func = 1;
	  break;
	case 'v':
	  global_unset_var = 1;
	  break;
	case 'n':
	  nameref = 1;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }

  list = loptend;

  if (global_unset_func && global_unset_var)
    {
      builtin_error (_("cannot simultaneously unset a function and a variable"));
      return (EXECUTION_FAILURE);
    }
  else if (unset_function && nameref)
    nameref = 0;

#if defined (ARRAY_VARS)
  base_vflags = array_expand_once ? VA_NOEXPAND : 0;
#endif

  while (list)
    {
      SHELL_VAR *var;
      int tem;
#if defined (ARRAY_VARS)
      char *t;
#endif

      name = list->word->word;

      unset_function = global_unset_func;
      unset_variable = global_unset_var;

#if defined (ARRAY_VARS)
      vflags = builtin_arrayref_flags (list->word, base_vflags);
      unset_array = 0;
      /* XXX valid array reference second arg was 0 */
      /* XXX tokenize_array_reference modifies NAME if it succeeds */
      if (unset_function == 0 && nameref == 0 && tokenize_array_reference (name, vflags, &t))
	unset_array = 1;
#endif

      /* Get error checking out of the way first.  The low-level functions
	 just perform the unset, relying on the caller to verify. */
      valid_id = valid_identifier (name);

      /* Whether or not we are in posix mode, if neither -f nor -v appears,
	 skip over trying to unset variables with invalid names and just
	 treat them as potential shell function names. */
      if (global_unset_func == 0 && global_unset_var == 0 && valid_id == 0)
	{
#if defined (ARRAY_VARS)
	  if (unset_array)
	    RESTORE_NAME ();
#endif
	  unset_variable = unset_array = 0;
	  unset_function = 1;
	}

      /* Bash allows functions with names which are not valid identifiers
	 to be created when not in posix mode, so check only when in posix
	 mode when unsetting a function. */
      if (unset_function == 0 && valid_id == 0)
	{
	  sh_invalidid (name);
	  posix_utility_error++;
	  NEXT_VARIABLE ();
	}

      /* Search for functions here if -f supplied or if NAME cannot be a
	 variable name. */
      var = unset_function ? find_function (name)
			   : (nameref ? find_variable_last_nameref (name, 0) : find_variable (name));

      /* Some variables (but not functions yet) cannot be unset, period. */
      if (var && unset_function == 0 && non_unsettable_p (var))
	{
	  builtin_error (_("%s: cannot unset"), name);
	  posix_utility_error++;
	  NEXT_VARIABLE ();
	}

      /* if we have a nameref we want to use it */
      if (var && unset_function == 0 && nameref == 0 && STREQ (name, name_cell(var)) == 0)
	name = name_cell (var);

      /* Posix.2 says try variables first, then functions.  If we would
	 find a function after unsuccessfully searching for a variable,
	 note that we're acting on a function now as if -f were
	 supplied.  The readonly check below takes care of it. */
      if (var == 0 && nameref == 0 && unset_variable == 0 && unset_function == 0)
	{
#if defined (ARRAY_VARS)
	  /* We modified NAME in the call to tokenize_array_reference, so we
	     need to restore it here. We turned the original `[' and `]' into
	     NULL, to isolate the array name and subscript. This only happens
	     if tokenize_array_reference succeeds with a non-NULL subscript
	     pointer, and UNSET_ARRAY is set to 1 only in this case. */
	  if (unset_array)
	    {
	      RESTORE_NAME();
	      unset_array = 0;
	    }
#endif
	  if (var = find_function (name))
	    unset_function = 1;
	}

      /* Posix.2 says that unsetting readonly variables is an error. */
      if (var && readonly_p (var))
	{
	  builtin_error (_("%s: cannot unset: readonly %s"),
			 var->name, unset_function ? "function" : "variable");
	  posix_utility_error++;
	  NEXT_VARIABLE ();
	}

      /* Unless the -f option is supplied, the name refers to a variable. */
#if defined (ARRAY_VARS)
      if (var && unset_array)
	{
	  if (shell_compatibility_level <= 51)
	    vflags |= VA_ALLOWALL;

	  /* Let unbind_array_element decide what to do with non-array vars */
	  tem = unbind_array_element (var, t, vflags);	/* XXX new third arg */
	  if (tem == -2 && array_p (var) == 0 && assoc_p (var) == 0)
	    {
	      builtin_error (_("%s: not an array variable"), var->name);
	      NEXT_VARIABLE ();
	    }
	  else if (tem < 0)
	    any_failed++;
	}
      else
#endif /* ARRAY_VARS */
      /* If we're trying to unset a nameref variable whose value isn't a set
	 variable, make sure we still try to unset the nameref's value */
      if (var == 0 && nameref == 0 && unset_function == 0)
	{
	  var = find_variable_last_nameref (name, 0);
	  if (var && nameref_p (var))
	    {
#if defined (ARRAY_VARS)
	      if (valid_array_reference (nameref_cell (var), 0))
		{
		  int len;

		  tname = savestring (nameref_cell (var));
		  tem = 0;
		  if (var = array_variable_part (tname, 0, &t, &len))
		    {
		      /* change to what unbind_array_element now expects */
		      if (t[len - 1] == ']')
			t[len - 1] = 0;
		      tem = unbind_array_element (var, t, vflags);	/* XXX new third arg */
		    }
		  free (tname);
		}
	      else
#endif
		tem = unbind_variable (nameref_cell (var));
	    }
	  else if (posixly_correct && var && tempvar_p (var))
	    tem = posix_unbind_tempvar (name);
	  else
	    tem = unbind_variable (name);
	}
      else if (posixly_correct && unset_function == 0 && nameref == 0 && var && tempvar_p (var))
	tem = posix_unbind_tempvar (name);
      else
	tem = unset_function ? unbind_func (name) : (nameref ? unbind_nameref (name) : unbind_variable (name));

      /* This is what Posix.2 says:  ``If neither -f nor -v
	 is specified, the name refers to a variable; if a variable by
	 that name does not exist, it is unspecified whether  a function
	 by that name, if any, shall be unset.'' The unspecified part is a
	 recent addition, so we continue to try to unset a shell function if
	 we don't find a variable named NAME. */
      if (tem == -1 && nameref == 0 && unset_function == 0 && unset_variable == 0)
	tem = unbind_func (name);

      name = list->word->word;		/* reset above for namerefs */

      /* SUSv3, POSIX.1-2001 say:  ``Unsetting a variable or function that
	 was not previously set shall not be considered an error.'' */

      if (unset_function == 0)
	stupidly_hack_special_variables (name);

      list = list->next;
    }

  return (any_failed ? (posix_utility_error ? EX_UTILERROR : EXECUTION_FAILURE) : EXECUTION_SUCCESS);
}

$BUILTIN shopt
$FUNCTION shopt_builtin
$SHORT_DOC shopt [-pqsu] [-o] [optname ...]
Set and unset shell options.

Change the setting of each shell option OPTNAME.  Without any option
arguments, list each supplied OPTNAME, or all shell options if no
OPTNAMEs are given, with an indication of whether or not each is set.

Options:
  -o	restrict OPTNAMEs to those defined for use with `set -o'
  -p	print each shell option with an indication of its status
  -q	suppress output
  -s	enable (set) each OPTNAME
  -u	disable (unset) each OPTNAME

Exit Status:
Returns success if OPTNAME is enabled; fails if an invalid option is
given or OPTNAME is disabled.
$END

#define UNSETOPT	0
#define SETOPT		1

#define OPTFMT		"%-15s\t%s\n"

extern int allow_null_glob_expansion, fail_glob_expansion, glob_dot_filenames;
extern int cdable_vars, mail_warning, source_uses_path;
extern int no_exit_on_failed_exec, print_shift_error;
extern int check_hashed_filenames, promptvars;
extern int cdspelling, expand_aliases;
extern int extended_quote;
extern int check_window_size;
extern int glob_ignore_case, match_ignore_case;
extern int hup_on_exit;
extern int xpg_echo;
extern int gnu_error_format;
extern int check_jobs_at_exit;
extern int autocd;
extern int glob_star;
extern int glob_asciirange;
extern int glob_always_skip_dot_and_dotdot;
extern int lastpipe_opt;
extern int inherit_errexit;
extern int localvar_inherit;
extern int localvar_unset;
extern int varassign_redir_autoclose;
extern int singlequote_translations;
extern int patsub_replacement;
extern int bash_source_fullpath;

#if defined (EXTENDED_GLOB)
extern int extended_glob;
#endif

#if defined (READLINE)
extern int complete_fullquote;
extern int dircomplete_expand;
extern int dircomplete_spelling;
extern int force_fignore;
extern int hist_verify;
extern int history_reediting;
extern int no_empty_command_completion;
extern int perform_hostname_completion;

extern int enable_hostname_completion (int);
#endif

#if defined (PROGRAMMABLE_COMPLETION)
extern int prog_completion_enabled;
extern int progcomp_alias;
#endif

#if defined (DEBUGGER)
extern int debugging_mode;
#endif

#if defined (ARRAY_VARS)
extern int array_expand_once;
int expand_once_flag;
#endif

#if defined (SYSLOG_HISTORY)
extern int syslog_history;
#endif

static void shopt_error (char *);

static int set_shellopts_after_change (char *, int);
static int set_compatibility_level (char *, int);

#if defined (RESTRICTED_SHELL)
static int set_restricted_shell (char *, int);
#endif

#if defined (READLINE)
static int shopt_enable_hostname_completion (char *, int);
static int shopt_set_complete_direxpand (char *, int);
#endif

#if defined (ARRAY_VARS)
static int set_array_expand (char *, int);
#endif

#if defined (EXTENDED_GLOB)
int extglob_flag = EXTGLOB_DEFAULT;
static int shopt_set_extglob (char *, int);
#endif

int expaliases_flag = 0;
static int shopt_set_expaliases (char *, int);

static int shopt_set_debug_mode (char *, int);

static int shopt_login_shell;
static int shopt_compat31;
static int shopt_compat32;
static int shopt_compat40;
static int shopt_compat41;
static int shopt_compat42;
static int shopt_compat43;
static int shopt_compat44;

typedef int shopt_set_func_t (char *, int);

/* If you add a new variable name here, make sure to set the default value
   appropriately in reset_shopt_options. */

static struct {
  char *name;
  int  *value;
  shopt_set_func_t *set_func;
} shopt_vars[] = {
#if defined (ARRAY_VARS)
  { "array_expand_once", &expand_once_flag, set_array_expand },
  { "assoc_expand_once", &expand_once_flag, set_array_expand },
#endif
  { "autocd", &autocd, (shopt_set_func_t *)NULL },
#if defined (ARRAY_VARS)
  { "bash_source_fullpath", &bash_source_fullpath, (shopt_set_func_t *)NULL },
#endif
  { "cdable_vars", &cdable_vars, (shopt_set_func_t *)NULL },
  { "cdspell", &cdspelling, (shopt_set_func_t *)NULL },
  { "checkhash", &check_hashed_filenames, (shopt_set_func_t *)NULL },
#if defined (JOB_CONTROL)
  { "checkjobs", &check_jobs_at_exit, (shopt_set_func_t *)NULL },
#endif
  { "checkwinsize", &check_window_size, (shopt_set_func_t *)NULL },
#if defined (HISTORY)
  { "cmdhist", &command_oriented_history, (shopt_set_func_t *)NULL },
#endif
  { "compat31", &shopt_compat31, set_compatibility_level },
  { "compat32", &shopt_compat32, set_compatibility_level },
  { "compat40", &shopt_compat40, set_compatibility_level },
  { "compat41", &shopt_compat41, set_compatibility_level },
  { "compat42", &shopt_compat42, set_compatibility_level },
  { "compat43", &shopt_compat43, set_compatibility_level },
  { "compat44", &shopt_compat44, set_compatibility_level },
#if defined (READLINE)
  { "complete_fullquote", &complete_fullquote, (shopt_set_func_t *)NULL},
  { "direxpand", &dircomplete_expand, shopt_set_complete_direxpand },
  { "dirspell", &dircomplete_spelling, (shopt_set_func_t *)NULL },
#endif
  { "dotglob", &glob_dot_filenames, (shopt_set_func_t *)NULL },
  { "execfail", &no_exit_on_failed_exec, (shopt_set_func_t *)NULL },
  { "expand_aliases", &expaliases_flag, shopt_set_expaliases },
#if defined (DEBUGGER)
  { "extdebug", &debugging_mode, shopt_set_debug_mode },
#endif
#if defined (EXTENDED_GLOB)
  { "extglob", &extglob_flag, shopt_set_extglob },
#endif
  { "extquote", &extended_quote, (shopt_set_func_t *)NULL },
  { "failglob", &fail_glob_expansion, (shopt_set_func_t *)NULL },
#if defined (READLINE)
  { "force_fignore", &force_fignore, (shopt_set_func_t *)NULL },
#endif
  { "globasciiranges", &glob_asciirange, (shopt_set_func_t *)NULL },
  { "globskipdots", &glob_always_skip_dot_and_dotdot, (shopt_set_func_t *)NULL },
  { "globstar", &glob_star, (shopt_set_func_t *)NULL },
  { "gnu_errfmt", &gnu_error_format, (shopt_set_func_t *)NULL },
#if defined (HISTORY)
  { "histappend", &force_append_history, (shopt_set_func_t *)NULL },
#endif
#if defined (READLINE)
  { "histreedit", &history_reediting, (shopt_set_func_t *)NULL },
  { "histverify", &hist_verify, (shopt_set_func_t *)NULL },
  { "hostcomplete", &perform_hostname_completion, shopt_enable_hostname_completion },
#endif
  { "huponexit", &hup_on_exit, (shopt_set_func_t *)NULL },
  { "inherit_errexit", &inherit_errexit, (shopt_set_func_t *)NULL },
  { "interactive_comments", &interactive_comments, set_shellopts_after_change },
  { "lastpipe", &lastpipe_opt, (shopt_set_func_t *)NULL },
#if defined (HISTORY)
  { "lithist", &literal_history, (shopt_set_func_t *)NULL },
#endif
  { "localvar_inherit", &localvar_inherit, (shopt_set_func_t *)NULL },
  { "localvar_unset", &localvar_unset, (shopt_set_func_t *)NULL },
  { "login_shell", &shopt_login_shell, set_login_shell },
  { "mailwarn", &mail_warning, (shopt_set_func_t *)NULL },
#if defined (READLINE)
  { "no_empty_cmd_completion", &no_empty_command_completion, (shopt_set_func_t *)NULL },
#endif
  { "nocaseglob", &glob_ignore_case, (shopt_set_func_t *)NULL },
  { "nocasematch", &match_ignore_case, (shopt_set_func_t *)NULL },
  { "noexpand_translation", &singlequote_translations, (shopt_set_func_t *)NULL },
  { "nullglob",	&allow_null_glob_expansion, (shopt_set_func_t *)NULL },
  { "patsub_replacement", &patsub_replacement, (shopt_set_func_t *)NULL },
#if defined (PROGRAMMABLE_COMPLETION)
  { "progcomp", &prog_completion_enabled, (shopt_set_func_t *)NULL },
#  if defined (ALIAS)
  { "progcomp_alias", &progcomp_alias, (shopt_set_func_t *)NULL },
#  endif
#endif
  { "promptvars", &promptvars, (shopt_set_func_t *)NULL },
#if defined (RESTRICTED_SHELL)
  { "restricted_shell", &restricted_shell, set_restricted_shell },
#endif
  { "shift_verbose", &print_shift_error, (shopt_set_func_t *)NULL },
  { "sourcepath", &source_uses_path, (shopt_set_func_t *)NULL },
#if defined (SYSLOG_HISTORY) && defined (SYSLOG_SHOPT)
  { "syslog_history", &syslog_history, (shopt_set_func_t *)NULL },
#endif
  { "varredir_close", &varassign_redir_autoclose, (shopt_set_func_t *)NULL },
  { "xpg_echo", &xpg_echo, (shopt_set_func_t *)NULL },
  { (char *)0, (int *)0, (shopt_set_func_t *)NULL }
};

#define N_SHOPT_OPTIONS		(sizeof (shopt_vars) / sizeof (shopt_vars[0]))

#define GET_SHOPT_OPTION_VALUE(i)	(*shopt_vars[i].value)

static int find_shopt (char *);
static int toggle_shopts (int, WORD_LIST *, int);
static void print_shopt (char *, int, int);
static int list_shopts (WORD_LIST *, int);
static int list_some_shopts (int, int);
static int list_shopt_o_options (WORD_LIST *, int);
static int list_some_o_options (int, int);
static int set_shopt_o_options (int, WORD_LIST *, int);

#define SFLAG	0x01
#define UFLAG	0x02
#define QFLAG	0x04
#define OFLAG	0x08
#define PFLAG	0x10

int
shopt_builtin (WORD_LIST *list)
{
  int opt, flags, rval;

  flags = 0;
  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "psuoq")) != -1)
    {
      switch (opt)
	{
	case 's':
	  flags |= SFLAG;
	  break;
	case 'u':
	  flags |= UFLAG;
	  break;
	case 'q':
	  flags |= QFLAG;
	  break;
	case 'o':
	  flags |= OFLAG;
	  break;
	case 'p':
	  flags |= PFLAG;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if ((flags & (SFLAG|UFLAG)) == (SFLAG|UFLAG))
    {
      builtin_error (_("cannot set and unset shell options simultaneously"));
      return (EXECUTION_FAILURE);
    }

  rval = EXECUTION_SUCCESS;
  if ((flags & OFLAG) && ((flags & (SFLAG|UFLAG)) == 0))	/* shopt -o */
    rval = list_shopt_o_options (list, flags);
  else if (list && (flags & OFLAG))		/* shopt -so args */
    rval = set_shopt_o_options ((flags & SFLAG) ? FLAG_ON : FLAG_OFF, list, flags & QFLAG);
  else if (flags & OFLAG)	/* shopt -so */
    rval = list_some_o_options ((flags & SFLAG) ? 1 : 0, flags);
  else if (list && (flags & (SFLAG|UFLAG)))	/* shopt -su args */
    rval = toggle_shopts ((flags & SFLAG) ? SETOPT : UNSETOPT, list, flags & QFLAG);
  else if ((flags & (SFLAG|UFLAG)) == 0)	/* shopt [args] */
    rval = list_shopts (list, flags);
  else						/* shopt -su */
    rval = list_some_shopts ((flags & SFLAG) ? SETOPT : UNSETOPT, flags);
  return (rval);
}

/* Reset the options managed by `shopt' to the values they would have at
   shell startup.  Variables from shopt_vars. */
void
reset_shopt_options (void)
{
  autocd = cdable_vars = cdspelling = 0;
  check_hashed_filenames = CHECKHASH_DEFAULT;
  check_window_size = CHECKWINSIZE_DEFAULT;
  allow_null_glob_expansion = glob_dot_filenames = 0;
  no_exit_on_failed_exec = 0;
  expand_aliases = expaliases_flag = 0;
  extended_quote = 1;
  fail_glob_expansion = 0;
  glob_asciirange = GLOBASCII_DEFAULT;
  glob_star = 0;
  gnu_error_format = 0;
  hup_on_exit = 0;
  inherit_errexit = 0;
  interactive_comments = 1;
  lastpipe_opt = 0;
  localvar_inherit = localvar_unset = 0;
  mail_warning = 0;
  glob_ignore_case = match_ignore_case = 0;
  print_shift_error = 0;
  source_uses_path = promptvars = 1;
  bash_source_fullpath = 0;
  varassign_redir_autoclose = 0;
  singlequote_translations = 0;
  patsub_replacement = PATSUB_REPLACE_DEFAULT;

#if defined (JOB_CONTROL)
  check_jobs_at_exit = 0;
#endif

#if defined (EXTENDED_GLOB)
  extended_glob = extglob_flag = EXTGLOB_DEFAULT;
#endif
  glob_always_skip_dot_and_dotdot = 1;		/* new default as of bash-5.2 */

#if defined (ARRAY_VARS)
  expand_once_flag = array_expand_once = 0;
#endif

#if defined (HISTORY)
  literal_history = 0;
  force_append_history = 0;
  command_oriented_history = 1;
#endif

#if defined (SYSLOG_HISTORY)
#  if defined (SYSLOG_SHOPT)
  syslog_history = SYSLOG_SHOPT;
#  else
  syslog_history = 1;
#  endif /* SYSLOG_SHOPT */
#endif

#if defined (READLINE)
  complete_fullquote = 1;
  force_fignore = 1;
  hist_verify = history_reediting = 0;
  perform_hostname_completion = 1;
#  if DIRCOMPLETE_EXPAND_DEFAULT
  dircomplete_expand = 1;
#  else
  dircomplete_expand = 0;
#endif
  dircomplete_spelling = 0;
  no_empty_command_completion = 0;
#endif

#if defined (PROGRAMMABLE_COMPLETION)
  prog_completion_enabled = 1;
#  if defined (ALIAS)
  progcomp_alias = 0;
#  endif
#endif

#if defined (DEFAULT_ECHO_TO_XPG) || defined (STRICT_POSIX)
  xpg_echo = 1;
#else
  xpg_echo = 0;
#endif /* DEFAULT_ECHO_TO_XPG */

#if defined (DEBUGGER)
  debugging_mode = 0;
#endif

  shopt_login_shell = login_shell;
}

static int
find_shopt (char *name)
{
  int i;

  for (i = 0; shopt_vars[i].name; i++)
    if (STREQ (name, shopt_vars[i].name))
      return i;
  return -1;
}

static void
shopt_error (char *s)
{
  builtin_error (_("%s: invalid shell option name"), s);
}

static int
toggle_shopts (int mode, WORD_LIST *list, int quiet)
{
  WORD_LIST *l;
  int ind, rval;
  SHELL_VAR *v;

  for (l = list, rval = EXECUTION_SUCCESS; l; l = l->next)
    {
      ind = find_shopt (l->word->word);
      if (ind < 0)
	{
	  shopt_error (l->word->word);
	  rval = EXECUTION_FAILURE;
	}
      else
	{
	  *shopt_vars[ind].value = mode;	/* 1 for set, 0 for unset */
	  if (shopt_vars[ind].set_func)
	    (*shopt_vars[ind].set_func) (shopt_vars[ind].name, mode);
	}
    }

  /* Don't set $BASHOPTS here if it hasn't already been initialized */
  if (v = find_variable ("BASHOPTS"))
    set_bashopts ();
  return (rval);
}

static void
print_shopt (char *name, int val, int flags)
{
  if (flags & PFLAG)
    printf ("shopt %s %s\n", val ? "-s" : "-u", name);
  else
    printf (OPTFMT, name, val ? on : off);
}

/* List the values of all or any of the `shopt' options.  Returns 0 if
   all were listed or all variables queried were on; 1 otherwise. */
static int
list_shopts (WORD_LIST *list, int flags)
{
  WORD_LIST *l;
  int i, val, rval;

  if (list == 0)
    {
      for (i = 0; shopt_vars[i].name; i++)
	{
	  val = *shopt_vars[i].value;
	  if ((flags & QFLAG) == 0)
	    print_shopt (shopt_vars[i].name, val, flags);
	}
      return (sh_chkwrite (EXECUTION_SUCCESS));
    }

  for (l = list, rval = EXECUTION_SUCCESS; l; l = l->next)
    {
      i = find_shopt (l->word->word);
      if (i < 0)
	{
	  shopt_error (l->word->word);
	  rval = EXECUTION_FAILURE;
	  continue;
	}
      val = *shopt_vars[i].value;
      if (val == 0)
	rval = EXECUTION_FAILURE;
      if ((flags & QFLAG) == 0)
	print_shopt (l->word->word, val, flags);
    }

  return (sh_chkwrite (rval));
}

static int
list_some_shopts (int mode, int flags)
{
  int val, i;

  for (i = 0; shopt_vars[i].name; i++)
    {
      val = *shopt_vars[i].value;
      if (((flags & QFLAG) == 0) && mode == val)
	print_shopt (shopt_vars[i].name, val, flags);
    }
  return (sh_chkwrite (EXECUTION_SUCCESS));
}

static int
list_shopt_o_options (WORD_LIST *list, int flags)
{
  WORD_LIST *l;
  int val, rval;

  if (list == 0)
    {
      if ((flags & QFLAG) == 0)
	list_minus_o_opts (-1, (flags & PFLAG));
      return (sh_chkwrite (EXECUTION_SUCCESS));
    }

  for (l = list, rval = EXECUTION_SUCCESS; l; l = l->next)
    {
      val = minus_o_option_value (l->word->word);
      if (val == -1)
	{
	  sh_invalidoptname (l->word->word);
	  rval = EXECUTION_FAILURE;
	  continue;
	}
      if (val == 0)
	rval = EXECUTION_FAILURE;
      if ((flags & QFLAG) == 0)
	{
	  if (flags & PFLAG)
	    printf ("set %co %s\n", val ? '-' : '+', l->word->word);
	  else
	    printf (OPTFMT, l->word->word, val ? on : off);
	}
    }
  return (sh_chkwrite (rval));
}

static int
list_some_o_options (int mode, int flags)
{
  if ((flags & QFLAG) == 0)
    list_minus_o_opts (mode, (flags & PFLAG));
  return (sh_chkwrite (EXECUTION_SUCCESS));
}

static int
set_shopt_o_options (int mode, WORD_LIST *list, int quiet)
{
  WORD_LIST *l;
  int rval;

  for (l = list, rval = EXECUTION_SUCCESS; l; l = l->next)
    {
      if (set_minus_o_option (mode, l->word->word) == EXECUTION_FAILURE)
	rval = EXECUTION_FAILURE;
    }
  set_shellopts ();
  return rval;
}

/* If we set or unset interactive_comments with shopt, make sure the
   change is reflected in $SHELLOPTS. */
static int
set_shellopts_after_change (char *option_name, int mode)
{
  set_shellopts ();
  return (0);
}

static int
shopt_set_debug_mode (char *option_name, int mode)
{
#if defined (DEBUGGER)
  error_trace_mode = function_trace_mode = debugging_mode;
  set_shellopts ();
  if (debugging_mode)
    init_bash_argv ();
#endif
  return (0);
}

static int
shopt_set_expaliases (char *option_name, int mode)
{
  expand_aliases = expaliases_flag;
  return 0;
}

#if defined (EXTENDED_GLOB)
static int
shopt_set_extglob (char *option_name, int mode)
{
  extended_glob = extglob_flag;
  return 0;
}
#endif

#if defined (READLINE)
static int
shopt_enable_hostname_completion (char *option_name, int mode)
{
  return (enable_hostname_completion (mode));
}
#endif

static int
set_compatibility_level (char *option_name, int mode)
{
  int ind, oldval;
  char *rhs;

  /* If we're unsetting one of the compatibility options, make sure the
     current value is in the range of the compatNN space. */
  oldval = (mode == 0) ? shell_compatibility_level : 0;

  /* If we're setting something, redo some of the work we did above in
     toggle_shopt().  Unset everything and reset the appropriate option
     based on OPTION_NAME. */
  if (mode)
    {
      shopt_compat31 = shopt_compat32 = 0;
      shopt_compat40 = shopt_compat41 = shopt_compat42 = shopt_compat43 = 0;
      shopt_compat44 = 0;
      ind = find_shopt (option_name);
      *shopt_vars[ind].value = mode;
    }

  /* Then set shell_compatibility_level based on what remains */
  if (shopt_compat31)
    shell_compatibility_level = 31;
  else if (shopt_compat32)
    shell_compatibility_level = 32;
  else if (shopt_compat40)
    shell_compatibility_level = 40;
  else if (shopt_compat41)
    shell_compatibility_level = 41;
  else if (shopt_compat42)
    shell_compatibility_level = 42;
  else if (shopt_compat43)
    shell_compatibility_level = 43;
  else if (shopt_compat44)
    shell_compatibility_level = 44;
  else if (oldval > 44 && shell_compatibility_level < DEFAULT_COMPAT_LEVEL)
    ;
  else
    shell_compatibility_level = DEFAULT_COMPAT_LEVEL;

  /* Make sure the current compatibility level is reflected in BASH_COMPAT */
  rhs = itos (shell_compatibility_level);
  bind_variable ("BASH_COMPAT", rhs, 0);
  free (rhs);

  return 0;
}

/* Set and unset the various compatibility options from the value of
   shell_compatibility_level; used by sv_shcompat */
void
set_compatibility_opts (void)
{
  shopt_compat31 = shopt_compat32 = 0;
  shopt_compat40 = shopt_compat41 = shopt_compat42 = shopt_compat43 = 0;
  shopt_compat44 = 0;
  switch (shell_compatibility_level)
    {
      case DEFAULT_COMPAT_LEVEL:
      case 51:			/* completeness */
      case 50:
	break;
      case 44:
	shopt_compat44 = 1; break;
      case 43:
	shopt_compat43 = 1; break;
      case 42:
	shopt_compat42 = 1; break;
      case 41:
	shopt_compat41 = 1; break;
      case 40:
	shopt_compat40 = 1; break;
      case 32:
	shopt_compat32 = 1; break;
      case 31:
	shopt_compat31 = 1; break;
    }
}

#if defined (READLINE)
static int
shopt_set_complete_direxpand (char *option_name, int mode)
{
  set_directory_hook ();
  return 0;
}
#endif

#if defined (RESTRICTED_SHELL)
/* Don't allow the value of restricted_shell to be modified. */

static int
set_restricted_shell (char *option_name, int mode)
{
  static int save_restricted = -1;

  if (save_restricted == -1)
    save_restricted = shell_is_restricted (shell_name);

  restricted_shell = save_restricted;
  return (0);
}
#endif /* RESTRICTED_SHELL */

/* Not static so shell.c can call it to initialize shopt_login_shell */
int
set_login_shell (char *option_name, int mode)
{
  shopt_login_shell = login_shell != 0;
  return (0);
}

char **
get_shopt_options (void)
{
  char **ret;
  int i;
  size_t n;

  n = sizeof (shopt_vars) / sizeof (shopt_vars[0]);
  ret = strvec_create (n + 1);
  for (i = 0; shopt_vars[i].name; i++)
    ret[i] = savestring (shopt_vars[i].name);
  ret[i] = (char *)NULL;
  return ret;
}

/*
 * External interface for other parts of the shell.  NAME is a string option;
 * MODE is 0 if we want to unset an option; 1 if we want to set an option.
 * REUSABLE is 1 if we want to print output in a form that may be reused.
 */
int
shopt_setopt (char *name, int mode)
{
  WORD_LIST *wl;
  int r;

  wl = add_string_to_list (name, (WORD_LIST *)NULL);
  r = toggle_shopts (mode, wl, 0);
  dispose_words (wl);
  return r;
}

int
shopt_listopt (char *name, int reusable)
{
  int i;

  if (name == 0)
    return (list_shopts ((WORD_LIST *)NULL, reusable ? PFLAG : 0));

  i = find_shopt (name);
  if (i < 0)
    {
      shopt_error (name);
      return (EXECUTION_FAILURE);
    }

  print_shopt (name, *shopt_vars[i].value, reusable ? PFLAG : 0);
  return (sh_chkwrite (EXECUTION_SUCCESS));
}

void
set_bashopts (void)
{
  char *value;
  char tflag[N_SHOPT_OPTIONS];
  int i, exported;
  size_t vsize, vptr;
  SHELL_VAR *v;

  for (vsize = i = 0; shopt_vars[i].name; i++)
    {
      tflag[i] = 0;
      if (GET_SHOPT_OPTION_VALUE (i))
	{
	  vsize += strlen (shopt_vars[i].name) + 1;
	  tflag[i] = 1;
	}
    }

  value = (char *)xmalloc (vsize + 1);

  for (i = vptr = 0; shopt_vars[i].name; i++)
    {
      if (tflag[i])
	{
	  strcpy (value + vptr, shopt_vars[i].name);
	  vptr += strlen (shopt_vars[i].name);
	  value[vptr++] = ':';
	}
    }

  if (vptr)
    vptr--;			/* cut off trailing colon */
  value[vptr] = '\0';

  v = find_variable ("BASHOPTS");

  /* Note whether or not the variable was exported so we can adjust after the
     assignment. */
  exported = v ? exported_p (v) : 0;

  /* ASS_FORCE so we don't have to temporarily turn off readonly */
  v = bind_variable ("BASHOPTS", value, ASS_FORCE);

  /* Turn the read-only attribute back on, and turn off the export attribute
     if it was set implicitly by mark_modified_vars and SHELLOPTS was not
     exported before we bound the new value. */
  VSETATTR (v, att_readonly);
  if (mark_modified_vars && exported == 0 && exported_p (v))
    VUNSETATTR (v, att_exported);

  free (value);
}

void
parse_bashopts (char *value)
{
  char *vname;
  int vptr, ind;

  vptr = 0;
  while (vname = extract_colon_unit (value, &vptr))
    {
      ind = find_shopt (vname);
      if (ind >= 0)
	{
          *shopt_vars[ind].value = 1;
	  if (shopt_vars[ind].set_func)
	    (*shopt_vars[ind].set_func) (shopt_vars[ind].name, 1);
	}
      free (vname);
    }
}

void
initialize_bashopts (int no_bashopts)
{
  char *temp;
  SHELL_VAR *var;

  if (no_bashopts == 0)
    {
      var = find_variable ("BASHOPTS");
      /* set up any shell options we may have inherited. */
      if (var && imported_p (var))
	{
	  temp = (array_p (var) || assoc_p (var)) ? (char *)NULL : savestring (value_cell (var));
	  if (temp)
	    {
	      parse_bashopts (temp);
	      free (temp);
	    }
	}
    }

  /* Set up the $BASHOPTS variable. */
  set_bashopts ();
}

#if defined (ARRAY_VARS)
static int
set_array_expand (char *option_name, int mode)
{
#if 0 /* leave this disabled */
  if (shell_compatibility_level <= 51)
#endif
    array_expand_once = expand_once_flag;
  return 0;
}
#endif
