#!/bin/sh
#
# mkdep - compute dependencies for the supplied source files
#
#   Copyright © 2024 The Free Software Foundation.
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Martin D Kealey <martin@kurahaupo.gen.nz>
#
# Modified by Chet Ramey <chet.ramey@case.edu> for inclusion in Bash
#

{ # parse whole script before starting

append_depfile=false
blddir=.
compiler=cc
debug=false
depfile=.depend
keep_output=false
keep_path=false
m_flag=-MM
patch_makefile=
skip_o=false
sort_depfile=false
srcdir=
topdir=

# These excluded pathnames doesn't work for every system (e.g., macOS), but
# this list is only needed if your compiler doesn't understand the -MM option;
# which usually does the right thing.
exclusion_list="\
: /usr/include
: /usr/lib"

# POSIX grep accepts multiple patterns separated by a newline
NL='
'

PROG=${0##*/}

usage()
{
  echo "$PROG: usage: $PROG [-a] [-c compiler] [-f depend_file] [-k f|p] [-m M|MM] [-p] [-P|--patch=[Makefile]] [-S SRCDIR] [-T SRCTOP] [--] [cc_flags] file ..." >&2
  exit 2
}


while getopts ac:f:k:m:psDPS:T:-: opt "$@"
do
  case $opt in
    a)
      # append to the dependency file (rather than overwriting it)
      append_depfile=true ;;

    c)
      # change compiler
      compiler=$OPTARG ;;

    e)
      # add item to the exclusion list
      exclusion_list="$exclusion_list$NL: $OPTARG"
      ;;

    f)
      # select a dependency file
      depfile=$OPTARG ;;

    k)
      case $OPTARG in
      f)  # Keep the temporary files on failure
	  keep_output=true ;;
      p)  # keep PATH from environment
	  keep_path=true ;;
      *) usage ;;
      esac ;;

    m)
      # report or ignore system-supplied #include files
      case $OPTARG in
      M | MM) m_flag=-$OPTARG ;;
      *) usage ;;
      esac ;;

    p)
      # produce “program: program.c”-style dependencies
      # (to avoid generating .o files)
      skip_o=true ;;

    D) debug=true ;;

    s)
      # "sort" after rewriting, to prevent creating duplicates
      sort_depfile=true
      ;;

    P)
      patch_makefile=Makefile ;;

    S)
      srcdir=$OPTARG ;;

    T)
      topdir=$OPTARG ;;

    -)
      LONGOPT=${OPTARG%%=*}
      OPTVAL=${OPTARG#"$LONGOPT"}
      case $OPTVAL in '') unset OPTVAL ;; *) OPTVAL=${OPTVAR#=} ; esac
      case $LONGOPT in
	n*p*)
	    case nopatch	in "$LONGOPT"*) patch_makefile= ; continue ; esac
	    case no-patch	in "$LONGOPT"*) patch_makefile= ; continue ; esac ;;
	p*) case patch-makefile	in "$LONGOPT"*) patch_makefile=${OPTVAL-Makefile} ; continue ; esac ;;
	s*) case srcdir		in "$LONGOPT"*) srcdir=${OPTVAL} ; continue ; esac
	    case srctop		in "$LONGOPT"*) topdir=${OPTVAL} ; continue ; esac
	    ;;
	t*) case topdir		in "$LONGOPT"*) topdir=${OPTVAL} ; continue ; esac ;;
      esac
      usage ;;

    ?)
      usage ;;
  esac

done

shift $(( $OPTIND - 1 ))

if [ $# = 0 ] ; then
  usage
fi

"$debug" && set -x

srcdir=${srcdir:+${srcdir%/}/}  # append a slash if non-empty and doesn't already end with one
topdir=${topdir:+${topdir%/}/}  # append a slash if non-empty and doesn't already end with one
blddir=${blddir:+${blddir%/}/}  # append a slash if non-empty and doesn't already end with one
xtopdir=${topdir:+'$(topdir)'/}

_=${srcdir:=$topdir}

rsrcdir=$( realpath "$srcdir" )/
rtopdir=$( realpath "$topdir" )/

case $rsrcdir in
  "$rtopdir"*) ;;
  *)	    echo >&2 "mkdep: src_dir (-S $rsrcdir) is not within top_dir (-T $rtopdir)" ; exit 2
esac

subdir=${rsrcdir#"$rtopdir"}      # where is the target dir within the build tree?

srcdir=${rsrcdir#"$PWD/"}
topdir=${rtopdir#"$PWD/"}

tgtdir=$blddir$subdir

"$keep_path" || export PATH=/bin:/usr/bin:/usr/local/bin:/opt/bin:$PATH

output=$depfile.mkdep$$

cleanup()
{
  rm -f "$output".*
  :
}

if "$keep_output"
then soft_cleanup() { :; }
else soft_cleanup() { cleanup ; }
fi

caught () {
  soft_cleanup
  trap 2	# SIGINT
  kill -2 $$
}

trap caught 1 2 3 13 15

"$compiler" "$m_flag" "$@" > "$output.1" || {
  ex=$?
  echo >&2 "mkdep: compilation failed; exit status $ex."
  soft_cleanup
  exit "$ex"
}

# (1) roll up lines ending with \\
# (2) split each dependency pair into a separate line

sed '
    s@ \./@ @g
    :a
    / \\$/ {
      N
      s/[[:space:]]*\\\n[[:space:]]*/ /
      ta
      s/\\$//
    }
    s/  *$//
    /^[^ ]*:$/d
    :b
    /^[^ :][^ :]*:/ {
      s@^\([^ :][^ :]*: \)\([^ ][^ ]*\) @\1\2\n\1@
      P
      D
      tb
    }
  ' < "$output.1" > "$output.2" &&

if test -n "$exclusion_list"
then
  grep -vF "${exclusion_list#$NL}"  < "$output.2" > "$output.3"
else
  ln "$output.2" "$output.3"
fi &&

# If the real target is a completed executable, create a dependency list
# directly targetting it, rather than the intermediate .o file(s).

if "$skip_o"
then
  sed 's@\.o: @: @' < "$output.3" > "$output.4"
else
  ln "$output.3" "$output.4"
fi &&

# Canonicalize paths changing A/B/C/../../D to A/D


# Canonicalize paths changing A/B/C/../../D to A/D

sed '
    :a
    s@^\./@@
    s@ \./@ @g
    s@/\./@/@g
    ta
    :b
    s@^[^/. ][^/ ]*/\.\./@@
    s@ [^/. ][^/ ]*/\.\./@ @g
    s@/[^/. ][^/ ]*/\.\./@/@g
    tb
  ' < "$output.4" > "$output.5" &&


# Sort the generated dependency list to eliminate duplicates

sort -u "$output.5" > "$output.6" &&

# Optionally incorporate the original depfile

if "$append_depfile"
then
  cat "$depfile" "$output.6" > "$output.7"
else
  ln "$output.6" "$output.7"
fi &&

# Optionally sort the entire output (this only makes a difference if
# incorporating the original depfile rather than overwriting it.

if "$sort_depfile"
then
  sort -u "$output.7" > "$output.8"
else
  ln "$output.7" "$output.8"
fi &&

# Rewrite paths as needed

while
  IFS= read -r line
do
  case $line in
    '' |\
    '#'* |\
    *': $'* ) echo "$line" ;;
    *': '*)
      s=${line#*': '}
      t=${line%%': '*}
      t=${t#././} t=${t#./}

      x=$topdir$subdir
      while
	case $x///$s in
	  *///./*) s=${s#./} ;;
	  */.///*) x=${x%/.} ;;
	  */..///*) false ;;
	  */?*////../*) x=${x%/*/}/ s=${s#../} ;;
	  *) false ;;
	esac
      do : ; done

      printf '%s: %s\n' "$t" "$x$s"
      ;;
    * ) echo "$line"
      echo >&2 'Warning: copying unmatched line: '"$line"
      ;;
  esac
done < "$output.8" > "$output.9" &&

# If everything has worked, replace the depfile

mv "$output.9" "$depfile" &&

if [ -n "$patch_makefile" ]
then
  pmt=$patch_makefile.tmp$$
  {
    sed < "$patch_makefile" '/^#* *MKDEP-CUT-HERE/,$ d' &&
    echo '#####   MKDEP-CUT-HERE  #####   Generated dependencies below; DO NOT EDIT  #####' &&
    cat "$depfile"
  } > "$pmt" &&
  mv "$pmt" "$patch_makefile"
fi &&

cleanup &&

exit 0
}
