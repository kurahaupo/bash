#!/bin/sh
#
# mkdep - compute dependencies for the supplied source files
#
#   Copyright © 2024 The Free Software Foundation.
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Martin D Kealey <martin@kurahaupo.gen.nz>
#
# Modified by Chet Ramey <chet.ramey@case.edu> for inclusion in Bash
#

{ # parse whole script before starting

append_depfile=false
blddir=.
compiler=cc
debug=false
depfile=.depend
keep_output=false
keep_output_on_error=false
keep_path=false
m_flag=-MM
patch_makefile=
skip_o=false
presort_depfile=true
sort_depfile=false
srcdir=
topdir=

# These excluded pathnames doesn't work for every system (e.g., macOS), but
# this list is only needed if your compiler doesn't understand the -MM option;
# which usually does the right thing.
exclusion_list="\
: /usr/include
: /usr/lib"

# POSIX grep accepts multiple patterns separated by a newline
NL='
'

PROG=${0##*/}

die()
{
  ex=$?
  case $1 in EX_*) ex=2 ; shift ;; [0-9]*) ex=$1 ; shift ; esac
  echo "$PROG: $*"
  exit $ex
}

usage()
{
  echo "$PROG: usage: $PROG [-a] [-c compiler] [-f depend_file] [-k f|ff|p] [-m M|MM] [-p] [-P|--patch=[Makefile]] [-S SRCDIR] [-T SRCTOP] [--] [cc_flags] file ..." >&2
  exit 0
}

bad_usage()
{
  echo "$PROG: usage: $PROG [-a] [-c compiler] [-f depend_file] [-k f|ff|p] [-m M|MM] [-p] [-P|--patch=[Makefile]] [-S SRCDIR] [-T SRCTOP] [--] [cc_flags] file ..." >&2
  exit 2
}


while getopts ac:f:k:m:psDPS:T:-: opt "$@"
do
  case $opt in
    a)
      # append to the dependency file (rather than overwriting it)
      append_depfile=true ;;

    c)
      # change compiler
      compiler=$OPTARG
      ;;

    e)
      # add item to the exclusion list
      exclusion_list="$exclusion_list$NL: $OPTARG"
      ;;

    f)
      # select a dependency file
      depfile=$OPTARG
      ;;

    k)
      case $OPTARG in
      f)
	# Keep the temporary files on failure
	keep_output_on_error=true ;;

      ff)
	# Keep the temporary files always
	keep_output=true ;;

      p)
	# keep PATH from environment
	keep_path=true ;;

      *) bad_usage ;;
      esac ;;

    m)
      # report or ignore system-supplied #include files
      case $OPTARG in
      M | MM) m_flag=-$OPTARG ;;
      *) bad_usage ;;
      esac
      ;;

    p)
      # produce “program: program.c”-style dependencies
      # (to avoid generating .o files)
      skip_o=true ;;

    s)
      # re-sort whole depfile, after normalisation and merging, to prevent
      # creating duplicates
      presort_depfile=false # no need for two sorts
      sort_depfile=true ;;

    D)
      debug=true ;;

    P)
      patch_makefile=Makefile ;;

    S)
      srcdir=$OPTARG
      ;;

    T)
      topdir=$OPTARG
      ;;

    -)
      LONGOPT=${OPTARG%%=*}
      OPTVAL=${OPTARG#"$LONGOPT"}
      case $OPTVAL in '') unset OPTVAL ;; *) OPTVAL=${OPTVAR#=} ; esac
      case $LONGOPT in
	n*p*)
	    case nopatch	in "$LONGOPT"*) patch_makefile= ; continue ; esac
	    case no-patch	in "$LONGOPT"*) patch_makefile= ; continue ; esac ;;
	p*) case patch-makefile	in "$LONGOPT"*) patch_makefile=${OPTVAL-Makefile} ; continue ; esac ;;
	s*) case srcdir		in "$LONGOPT"*) srcdir=${OPTVAL} ; continue ; esac
	    case srctop		in "$LONGOPT"*) topdir=${OPTVAL} ; continue ; esac
	    ;;
	t*) case topdir		in "$LONGOPT"*) topdir=${OPTVAL} ; continue ; esac ;;
      esac
      bad_usage ;;

    ?)
      bad_usage ;;
  esac

done

shift $(( $OPTIND - 1 ))

if [ $# = 0 ] ; then
  usage
fi

exclusion_list=${exclusion_list#"$NL"}

"$debug" && set -x

#
# There are 4 directories of interest
#   $blddir - the top of the target tree
#   $tgtdir - the target directory (within the target tree)
#   $topdir - the top of the source tree
#   $srcdir - the source directory (within the source tree) that corresponds to the target directory
# Which is to say, the relative paths from $topdir to $srcdir and from $blddir
# to $tgtdir must be the same. Moreover, $tgtdir must be $PWD (or '.'), because
# otherwise the paths produced by 'gcc -MM' will be wrong.

# For each given path, make sure it ends with a slash (or is empty)
srcdir=${srcdir:+${srcdir%/}/}
topdir=${topdir:+${topdir%/}/}
blddir=${blddir:+${blddir%/}/}

# Force paths to be empty rather than ./
srcdir=${srcdir#./}
topdir=${topdir#./}
blddir=${blddir#./}

# Minimize all paths:
#   - where a path is relative, leave it as-is
#   - if a path is a subdir of $PWD, strip the leading $PWD/
#   - if a path is a parent dir of $PWD, convert it to a chain of '../'
#   - all paths have a trailing '/' (unless it's empty, meaning $PWD); avoid './'
#   - set blddir to some repetition of '../'
#   - where a path is absolute and neither
#
# Various cases to cope with:
#       topdir                  srcdir                  subdir  blddir  tgtdir
#       [./]                    [./]                    [./]    [./]    [./]            when building in the source tree
#       ../                     [./]                    sub/    ../     [./]
#       ../../                  [./]                    s1/s2/  ../../  [./]
#
#       /abs/path/              /abs/path/              [./]    [./]    [./]            when building at an independent path
#       /abs/path/              /abs/path/sub/          sub/    ../     [./]
#       /abs/path/              /abs/path/s1/s2/        s1/s2/  ../../  [./]
#
#       (../)                   (../)                   [./]    [./]    [./]            when building in a subdir of the source tree
#       ../(../)                ../(../)sub/            sub/    ../     [./]
#       ../../(../)             ../../(../)s1/s2/       s1/s2/  ../../  [./]
#
#       (rel/)                  (rel/)                  [./]    [./]    [./]            when building in a parent directory of the source tree
#       ../../(rel/)            ../../(rel/)s1/s2/      s1/s2/  ../../  [./]
#
#       (../)(rel/)             (../)(rel/)             [./]    [./]    [./]            when building beside the source tree
#       ../(../)(rel/)          ../(../)(rel/)sub/      sub/    ../     [./]
#       ../../(../)(rel/)       ../../(../)(rel/)s1/s2/ s1/s2/  ../../  [./]

if test -z "$srcdir"
then
  # Building in the source tree
  tgtdir=
else

  # Get the relative path of the target dir within the build tree, or abort
  subdir=${srcdir#"$topdir"}
  case $subdir in
    /*) die 2 " src_dir (-S $srcdir) is not within top_dir (-T $topdir)" ;;
  esac

  # Make the reverse relative path
  # NB: this is a POSIX sh script, otherwise in Bash we could simply use:
  #   shopt -s extglob
  #   updir=${subdir//+([!\/])/..}
  updir= t=/$subdir
  while test / != "$t"
  do
    updir=../$updir
    t=${t%/*/}/
  done

  srcdir=${srcdir#"$PWD/"}
  topdir=${topdir#"$PWD/"}
  blddir=${blddir#"$PWD/"}

  # Verify that $tgtdir is $PWD, or die
  tgtdir=

  case $blddir$subdir in
    '' | "$updir$subdir" | "$PWD/" )
      blddir=$updir ;;

### Should not be needed, but left here as a worked example for future use...
#   "$subdir" | "$PWD$subdir" )
#     blddir=
#     tgtdir=$subdir
#     ;;

    *)
      # Give up if we're not in the right directory:
      # - if we don't cd, the generated target paths will be wrong;
      # - but if we do cd, relative filenames in "$@" will be wrong;
      die EX_UNAVAILABLE \
	"Error: must be run from the target directory; please 'cd $tgtdir' and try again."
      ;;
  esac

  "$keep_path" ||
    export PATH=/bin:/usr/bin:/usr/local/bin:/opt/bin:$PATH

fi

rewrite_path()
{
  case $1 in
    \#*) return ;;
    \$*) echo "$1" ; return ;;
  esac

  f=${1##*/}
  p=${1%"$f"}

  case $p in
    '' | ./ | "$PWD/" ) p= ;;

    /*/)
      common_prefix=${PWD%/}/ up2=
      while
	case $p in "$common_prefix"*) false ; esac &&
	! case $common_prefix in /*/) false ; esac
      do
	common_prefix=${common_prefix%/*/}/
	up2=../$up2
      done
      case $p in
	"$common_prefix"*)
	  p=$up2${p#"$common_prefix"}
	  ;;
      esac
      ;;

    # Handle case when PWD is /a/b/c/d and p is ../d or ../../c/d etc;
    # You might need to add more cases if 4 isn't enough.
    ../../../../"${PWD#"${PWD%/*/*/*/*}"}/" |\
       ../../../"${PWD#"${PWD%/*/*/*}"}/" |\
	  ../../"${PWD#"${PWD%/*/*}"}/" |\
	     ../"${PWD#"${PWD%/*}"}/" )
      p= ;;
  esac

  echo "$p$f"
}

rewrite()
{
  echo "# topdir=$topdir"
  echo "# srcdir=$srcdir"
  echo "# subdir=$subdir"
  echo "# blddir=$blddir"
  echo "# tgtdir=$tgtdir"
  echo "# PWD=$PWD"
  while
    IFS= read -r line
  do
    case $line in
      '' |\
      '#'* |\
      [$/]*': $'* ) echo "$line" ;;

      *': $'* ) echo "$tgtdir$line" ;;

      *': '*)
	s=${line#*': '}
	t=${line%%': '*}

	echo "$tgtdir${t#./}: $( rewrite_path "$s" )"
	;;
      * ) echo "$line"
	echo >&2 '# Warning: copying unmatched line: '"$line"
	;;
    esac
  done
} 2>&1

output=$depfile.mkdep$$

cleanup()
{
  rm -f "$output".*
  :
}

if "$keep_output"
then end_cleanup() { :; }
else end_cleanup() { cleanup ; }
fi

if "$keep_output_on_error"
then soft_cleanup() { :; }
else soft_cleanup() { cleanup ; }
fi

die()
{
  ex=$?
  soft_cleanup
  case $1 in EX_*) ex=2 ; shift ;; [0-9]*) ex=$1 ; shift ; esac
  echo "$PROG: $*"
  exit $ex
}

caught () {
  soft_cleanup
  trap 2	# SIGINT
  kill -2 $$
}

trap caught 1 2 3 13 15

"$compiler" "$m_flag" "$@" > "$output.1" || {
  ex=$?
  echo >&2 "mkdep: compilation failed; exit status $ex."
  soft_cleanup
  exit "$ex"
}

# (1) roll up lines ending with \\
# (2) split each dependency pair into a separate line

sed '
    s@ \./@ @g
    :a
    / \\$/ {
      N
      s/[[:space:]]*\\\n[[:space:]]*/ /
      ta
      s/\\$//
    }
    s/  *$//
    /^[^ ]*:$/d
    :b
    /^[^ :][^ :]*:/ {
      s@^\([^ :][^ :]*: \)\([^ ][^ ]*\) @\1\2\n\1@
      P
      D
      tb
    }
  ' < "$output.1" > "$output.2" || die 'Unrolling failed'

if test -n "$exclusion_list"
then
  grep -vF "$exclusion_list"  < "$output.2" > "$output.3"
else
  ln "$output.2" "$output.3"
fi || die 'Filtering failed'

# If the real target is a completed executable, create a dependency list
# directly targetting it, rather than the intermediate .o file(s).

if "$skip_o"
then
  sed 's@\.o: @: @' < "$output.3" > "$output.4"
else
  ln "$output.3" "$output.4"
fi || die 'Executable trimming failed'

# Canonicalize paths changing A/B/C/../../D to A/D

sed '
    :a
    s@^\./@@
    s@ \./@ @g
    s@/\./@/@g
    ta
    :b
    s@^[^/. ][^/ ]*/\.\./@@
    s@ [^/. ][^/ ]*/\.\./@ @g
    s@/[^/. ][^/ ]*/\.\./@/@g
    tb
  ' < "$output.4" > "$output.5" || die 'Path normalization failed'

# Sort the generated dependency list to eliminate duplicates

if "$presort_depfile"
then
  sort -u "$output.5" > "$output.6"
else
  ln "$output.5" "$output.6"
fi || die 'Pre-sorting failed'

# Optionally incorporate the original depfile

if "$append_depfile"
then
  cat "$depfile" "$output.6" > "$output.7"
else
  ln "$output.6" "$output.7"
fi || die 'Concatenation failed'

# Rewrite paths as needed

rewrite < "$output.7" > "$output.8" || die 'Rewriting failed'

# Sort the entire output (this only makes a difference if incorporating the
# original depfile rather than overwriting it.

if "$sort_depfile"
then
  sort -u "$output.8" > "$output.9"
else
  ln "$output.8" "$output.9"
fi || die 'Sorting failed'

# If everything has worked, replace the depfile

mv "$output.9" "$depfile" || die 'Installation failed'

# And then if requested, apply the patches to the Makefile

if [ -n "$patch_makefile" ]
then
  pmt=$patch_makefile.tmp$$
  {
    sed < "$patch_makefile" '/^#* *MKDEP-CUT-HERE/,$ d' &&
    echo '#####   MKDEP-CUT-HERE  #####   Generated dependencies below; DO NOT EDIT  #####' &&
    cat "$depfile"
  } > "$pmt" &&
  mv "$pmt" "$patch_makefile"
fi || die 'Patching failed'

end_cleanup

exit
}
